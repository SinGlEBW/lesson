 /*------------Массивы---------------*/
 let obj = {name: 'Вася', family: 'Пупкин', age: 25, city: 'Мухосранск'};
 let arrObj = [{name: 'Вася'},{name: 'Петя'},{name: 'Стас'},{name: 'Никола'},{name: 'Паша'}];
 let arrNumber = [4, 7, 2, -1, 13, -6, 25];
 let arrString = ["n", "n1", "n2", "n4", "n5"]; 
 let arrArr = [['name', 'name1'],['family', 'family1'],['age', 'age1']];
 var squared = [];
 console.log('');
/*-------------------------------------------------------------------------------------------------------- */
/*Создание Map объекта нужно в том случае если нужно хранить информацию как бы в ассоциативном масиве */
 let objMap = new Map();
 objMap.set("name", 'вася').set("name1", 'петя').set("name2", 'рома'); //добавили ключи и значения
 /*Как работают итераторы объекта Map. При обращении к функции next() через объект итератор, объект считате кол-во вызовов этой функции.
   Сама функция содержит в себе свойство value где содержится даные и свойство done которое определяет есть ли данные в свойстве value. Если есть в done = false.
   Каждый вызов выводит новое значение если. Как только кол-во значений заканчивается, свойство done переходит в true.
   Поэтому вызывая next через итератор objMap.entries() не можем получать по отдельности ключи и свойства.
   Ключи и значения это одна связка получаемая вызовом next(). Можно получать что-то одно или ключ или значение что израсходует один вызов next()*/
 function iteratorMap(kv) {
     for (let j in kv.next().value) { console.log(j); }   
     console.log('') 
     for (let j of kv.next().value) { console.log(j); } 
 };

 console.log(objMap);
 let kv = objMap.entries(); //передаёт чистый массив из 2х
 let key = objMap.keys();
 let value = objMap.values();
 /*>>>В функцию передавать разные итераторы для понимания как работают массивы в них<<<*/
 iteratorMap(kv); //чёто именованая функция помещёная до определения объектов не видит их. А говорили что видит))
 //iteratorMap(kv); //вот о чём говорил. 2й вызов будет лишним ил-за кол-ва вызваной next()

 console.log('');
 for (let i = 0; i < objMap.size; i++) {
     console.log(`${key.next().value} : ${value.next().value} : ${objMap}`)
 };
 /* for( in ) - возвращает индекс, for( of ) - возвращает значение. Эти циклы отдельны как for */

 /* Объект Map не возаращает индексы в чистом виде так что for( in ) не подходит. Работать будем чисто с даными масива в роли ключей и значений.
    Цикл for in и for of преобразуют поучаемые данные в натуральный массив с индексами и значениями. proto Array
    Обычный цикл for просто манипулирует даными как они есть. Без дополнительного кода не обойтись чтоб даные запихивать в массив.   */
 console.log('');
 for (var g of objMap) {
     console.log(`${g[0]} : ${g[1]}`);
 }
 //console.log(g);//глобально обявленая переменная цикла, получает поседний массив, а не весь.
 /*Если требуется работать с чистыми индексами массива.*/
 console.log('');
 let arr2 = [11, 123, 1];
 for (let h in arr2) {
     console.log(h)
 }

 /*Синаксис --   arr.forEach(callback(currentValue, index, arr), thisArg); 
   2й аргумент thisArg это название объекта с методами которого мы хотим поработать в 1м аргументе "callback" функции если нужна такая возможность.
   forEach удобен тем что его синтаксис понятен, ко всему прочему не нужно брать у объекта отдельные итераторы и их в отдельном виде перебирать
   что только увеличивает размер кода*/
 console.log('');
 objMap.forEach((value, index, objMapArg) => { // 3й аргумент это сам массив который перебирается
     console.log(`${index} : ${value} : ${objMapArg}`);
 });

 var myObject = {
    square: function (currentValue) {
        return currentValue * currentValue;
    }
};

 arrNumber.forEach(function (value) {
    squared.push(this.square(value)); //возаращаем в пустой массив "squared" результат который ворачивает вызваный метод square объекта myObject
}, myObject // объект, на который мы ссылаемся с использованием ключевого слова this 
);
console.log(squared);

 /*ВАЖНО использовать ES6 одновременно с ES5 иногда приводит к багам. Есть методы в масствах которые по разному отображают информацию используя обратные кавычки из ES6 */

 /*удобный способ отфильтровать массив
   filter, sort, map, every, some, reduce, reduceRight, find, findindex, */ 

/* Значения фильтрует по признакам. Воспользоватся логическими операторами. Масив с масивами 1й аргумент не обрабатывает 
  1й аргумент Фильтрует по значениям. Взаимодействие с индексами не предусмотренно.
  2й аргумент Фильтрует по индексам. Ведёт счёт с 1  индекса и до конца. 
  3й аргумент это сам массив. Можно выполнять методы масива столько раз сколько он имеет значений на борту */
let newArrFilter = arrObj.filter((value, index, arr) => {
    console.log(arr.length);
    console.log( arr.pop());//удаляет последний элемент
    return arr;
}); 
 /*Интересный случай. Цикл содержит 5 элементов. 1й цикл - (0 < 5),  2й цикл - (1 <  4), 3й цикл - (2  <  3), 4й не выполняет  - (3  <  2) */
 console.log(arrObj);
 console.log(newArrFilter);//хз почему вернул 3 элемента. Удаление же прошло.
 console.log('');

var arrNew11 = [];
for(var i = 0; i < arrNumber.length; i++){  
    arrNew11[i] = arrNumber;     
}
console.log(arrNew11);console.log('');

let arrObj1 = [{name: 'Жека'},{name: 'Боря'},{name: 'Илья'},{name: 'Гога'},{name: 'Глеб'}];
console.dir(arrNumber);
let arrSort = arrNumber.sort(function name(...a){//объекты смысла нет сортировать.
    //сравниваеться 2е с 1м
    console.dir(a);
    return  -1;
});
console.dir(arrSort);
/*
sort изменяет основной массив.
sort - сравинивает элементы массива в виде текста. Сравнение происходит в кодировкой unicode. 
"1", "22", "3" и т.д. 1й символ 22 меньше чем 3 Тип не изменяется.
В Unicode, числа находятся перед буквами в верхнем регистре, а те, в свою очередь, перед буквами в нижнем регистре.
*/



 /*
 1й аргумент возвращает все значения подсчитывая индексы от 0 до конца.Так же если это масив объектов то можно обращаться к его свойствам
 2й аргумент возвращает нумерацию индексов от 0 и до конца. 
 3й аргумент это массив масивов из его же масива. Через 3й аргумент так же можно обращаться к свойствам объекта если это масив объектов, просто предварительно указать нужный индекс */
 let newArrMap = arrObj1.map((value, index, arr) => {
     return arr[0]; //map такую запись `${index}` из-за ` ` . преобразовывает в тип string. так же можно заполнить весь масив даными которые указываем в return
 });
 console.dir(newArrMap); console.log('');
/*чем то похожий метод Array.from() - принимает строку разделяет её на много массивов по 1. 2й аргумент callback в который передаються поочерёдно весь массив из 1 аргумента */
/*-------------------------------------------------------------------------------------------------------------------------- */
/* Метод every вернёт true если возвращаемое условие верно для каждого значения в масиве.
   Так же every на пустом массиве возвращает true, в то время как some вернёт false */
 let newArrEvery = arrNumber.every((value, index, arr) => {
     return value > -2;//Если все значения в масиве будут больше -2, то true
 });
 console.log(newArrEvery); console.log('');

/* Метод some отличается от every тем что some возвращает true если хотябы одно значение в массиве подходит под условие.
   В обоих случаясь есть 2й аргумент индекс, то что 2й, что 3й аргумент практически не используются */
 let newArrSome = arrNumber.some((value, index, arr) => {
     return value > -2;//Если хотябы 1 значение в массиве будет больше -2, то true
 });



 console.log(newArrSome); console.log('');

 const names = ['sophie', 'george', 'waldo', 'stephen', 'henry'];
let includesWaldo = names.includes('waldo');//Если просто проверить есть ли в наличие что-то, то удобней этот метод.
 // includesWaldo получит значение true
/*---------------------------------------------------------------------------------------- */
let sum = 0;//значение нужно указывать для того что бы был операнд для выражения.
 for(let i = 0; i < arrNumber.length; i++){
    sum += arrNumber[i];//сумма масива. Заменой служит метод массива reduce
 }
 console.log(sum); console.dir('');

/* Метод reduce предназначен посчитывать сумму всех значений в массиве. Метод принимает по мимо callback функции ещё 2й параметр - это число служит для выражения как операнд с которым начинается взаимодействие. Обычно требуеться считать с 0 числа.
   Так же метод може ворачивать булевские значения если использовать логические операции.
1й аргумент. Это аргумент выступает в роли накопителя суммы. Возвращая условие 1й арг + 2й арг. получаем на каждой итерации цикла прибавку к 1му аргументу. Если указать 2м параметром метода reduсe значение, то оно будет выступать отправной точкой подсчёта.
2й аргумент показывает последнее значение массива.
3й аргумент показывает значение индекса считая от 0 (не length который прибавляет всегда прибавляет +1 чтобы имитировать счёт от 1). Можно тоже складывать с 1м аргументом.
4й аргумент сам массив.*/
 let newArrReduce = arrNumber.reduce((previousValue, lastValue, currentindex, arr) => {   
    return previousValue += lastValue;
   
}, 0); //2м параметром для метода reduce обязательно нужно передавать значение.

// reduce  считает ->[4, 7, 2, -1, 13, -6, 25]<- считает reduceRight
console.log(newArrReduce);console.dir('');


/*Метод reduceRight тот же reduce только */
let newArrReduceRight = arrNumber.reduceRight((previousValue, lastValue, index, arr) => {
    
    return previousValue += lastValue;
}, 0);
console.log(newArrReduceRight);console.dir('');

/*Find ищет и возвращает одно значение. Условие можно строить по значению или индексу
  через метод можно так же обращаться к свойствам объекта*/
let newArrFind = arrNumber.find((Value, index, arr) => {
    return Value > 4;
});
console.log(newArrFind);console.dir('');

/*FindIndex возвращает индекс в котором находится искомое значение. Условию можно строить по значению или индексу*/
let newArrFindIndex = arrNumber.findIndex((Value, index, arr) => {
    return index > 5;// не существующая ячейка показывает как ошибка -1
});
console.log(newArrFindIndex);console.dir('');

/* метод превращает массив в строку. В аргумент указывается то что должно разделять полученую строку. В стоке установлена запятая.
   Если работать в спарке с методом split, то чтобы убрать установленый в join separator, в splite нужно указать тот же separator*/
let arrJoin = arrString.join("1 ");
console.log(arrJoin);console.dir('');


/*Этим методом можно всю строку засутуть в 0 массив, ничего при этом не указав в аргументе, а можно по символьно собрать большой массив указать просто кавычки.
  Если добавить пробел между кавычками, то масив будет состоять из слов. 
  2 й параметр ограничивает размер массива на возврат.  */


let map = new Map([arrString]); //какой бы длины не был массив, Map принимает короткие массивы индексы 0 и 1, так что смысла нет добавлять в MAP длинные массивы
console.log(map);console.dir('');

let set = new Set(arrNumber);
console.log(set); console.dir('');

//from принимает 3 аргумента 1й то что нужно распихать в масив, 2й функцию которая будет влиять на массив, 3й this
console.dir(

    Array.from('123456789', (x) =>x * 2)
   
);

var s = new Set(['foo', window]); 
console.dir(s);
let arr3 = [];
for(value of s.values()){
   arr3.push(value);
}
console.dir(arr3);

console.dir(Array.from(s));
console.dir([...s]);


var m = new Map([[1, 2], [2, 4], [4, 8]]); 
let d = [];
for( value of m.entries()){
    for(item of value){
        d.push(item)
    }
    
}
console.dir(d);

let b = [];
for( value of m.entries()){
    b.push(...value) 
}
console.dir(b);

 let ar = Array.from(m);

 let f = [];
 for(let i = 0; i < ar.length; i++){
    f.push(...ar[i]);
 }
 console.dir(f);

/*Оператор spread ... копирует одно в другое */