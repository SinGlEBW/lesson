 //Создание объекта. синтаксис похож на css.Описание статичных свойств
 let person = {
     name: 'Толян',
     age: '21',
     color: 'red',
     //Создание функции метода внутри объекта
     /*Оказывается переменные в методе не имеют никакого отношения к статичным свойствам выше. Их можно назвать как угодно. 
     	this.название переменной это и есть инициализация новой переменной свойства*/
     Method1: function (a1, a2, a3) {
         this.name = a1;
         this.age = a2;
         this.city = a3;
     }
 }


 /*
 Создавать функции методы, можно вне объекта. Название можно давать на ходу. Методом считаеться та функция, которая вызываеться через объект.
 person.newMethod = function(a1, a2, a3){описание} // это инициализация функции метода для объекта
 */

 //---------------- Вывод статичных свойств--------------- 
 //Задание 1: Разобраться как при помощи вызова функции показать информацию всех статичных свойств.
 //Вариант 1.
 /*
 function nameFunction1() 
 {
 	console.log(person.name + '\n' + person.age + '\n' + person.color)
 }
 nameFunction1();
 */
 //А если свойства меняються динамически? Каждый раз забивать свойства вручную? Есть другой способ решить данную проблему и без повторений кода
 //Вариант 2. Выбор способа создания функции. Можно создать функицю безымянную и присвоить её переменной let nameFunction2 = function(){описание}
 //Я предпочитаю по старинке.
 function nameFunction2() {
     for (let n in person) { //аналог foreach с добавлением '' переменной n.

         switch (typeof person[n]) { //убираем лишний показ методов. нам нужны только свойства. приходиться создавать условие.
             case "function":
                 break;
             default:
                 console.log(person[n]);
         }
     }
 }

 nameFunction2();
 /* Почему person[n] использование квадратных скобок. Есть обращение к свойству обекта person['название свойства или метода']. 
    так вот цикл for in добавляет каждому полученому свойству или методу кавычки '' автоматически. Хотя через console.log(n) этого нет.
 	Поэтому такое написание person.n  не уместно т.к. нет такого синтаксиса person.'name' .... */

 //-------Разбор методов объекта и воздействие на свойства----

 /*Что мы имеем свойства в объекта которые можно менять обращаясь по отдельности и метод в объекте который живёт сам по себе со 
   своими свойствами. Допустим я хочу создавать объекты индивидуальные. Присваивая статичные свойства объекта, другим переменым 
   (выступающим как индивидуальный объект) Пример: let p1 = person; p1.name = 'Вася'; Смысла в этом мало.Изменяя p1, person.name перезапишется. 
   Вообщем-то если писать послеовательный код то это может сработать, всем объектам можно заменять значения свойств.
   Код получиться грамозким и прерастёт в копипаст. Куча объектов - куча копипаста. 

   Для этого нужен шаблон. Шаблоном выступает функция со своими переменными Пример так: */
 function newFunction3(a1, a2, a3) {
     let name = a1;
     let age = a2;
     let city = a3;
     return name + '\n' + age + '\n' + city;
 }
 p1 = newFunction3('Вася', 22, 'Н.Новгород');
 p2 = newFunction3(27, 'Пётр', 'Иваново'); //ничего не мешает здесь испортить запись
 p3 = new newFunction3('Саня', 25, 'Краснодар');
 console.log(p2);
 /*И т.д. 1е два не являються объектами. Если посмотреть console.log(typeof p1) будет string. Это значит что обращение к отдельным элементам 
   с помощью строки p1.name не выйдет. Ворачиваються все элементы с помощью return на одину переменную p1 */

 /*С p3 дела обстоят не корректно. p3 - объект, но не построена связь к свойствам. Для обращения к свойствам и методам 
   (когда объявляеться объект с помощью new - это указывает на динаическую память) невозможна без ключевого слова this
   Такая функция называеться Конструктор объекта. Тот же шаблон, но не требует return т.к. обращение происхдит к отдельным элементам свойств*/
 function newFunction4(a1, a2, a3) {
     this.name = a1;
     this.age = a2;
     this.city = a3;
 }

 p4 = new newFunction4('Андрей', 40, 'Шуя');
 p5 = new newFunction4('Слава', 30, 'Ярославль');
 console.log(p4.name);
 /*Что происходит в этой ситуации. Эта функция создана верно, но из-за имени выдаёт ошибку т.к. Это не создание метода объекта person

 function person(a1, a2, a3){
 	this.name = a1;
 	this.age = a2;
 	this.city = a3;
 }

 p6 = new person('Андрей', 40, 'Шуя'); //как только происходит вызов.Вызыват ошибку
 */

 person.Method1('Григорий', 27, 'Кинешма');
 console.log(person.name);
 console.log(person.city);

 /*
 Я полагаю переменные в методе не имеют никакого отношения к статичным свойствам выше. Их можно назвать как угодно. 
 this.название переменной это и есть инициализация новой переменной свойства. 

 Важно:  все переменные являются общими в объекте person. 
 При вызове метода в котором есть некие переменные они инициализируются. Приоритет у переменных в  методе выше. 
 Если встречаются одинаковые идентификаторы, то идентификаторы свойств объекта не вызываются и хранятся 
 где-то в памяти.При обнулении значения в переменной(свойства) метода. Возвращается значение свойства объекта.*/



