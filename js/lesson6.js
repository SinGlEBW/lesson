
/*ВАЖНО: Особенность JS(может и не только JS). Если закинуть в аргумент функции функцию с () - вызывающими скобками, то она выполнится 1й, а потом 
  будет выполняться основная функция и не важно указывал ли я при создании основной функции аргумент или нет. Конечно если мне нужно функцию передать, то аргумен обязательно указать.
  ГЛАВНЫЙ ОТВЕТ ДЛЯ МЕНЯ В БУДУЩЕМ. Зачем это надо? Можно же вызывать функции по нужному порядку и они выполнятся как надо,
  а вот оказываеться и нет. JavaScript пробегается по списку и не дожидается выполнения функции, переходит к следующей, он сразу
  берёться за выполнение следующих и т.д. Чуть ли не все одновременно выполняет и функции чем проще тем быстрей выполняються, а сложные позже,
  происходит беспорядочное выполнение функций. Для этого начали передавать в функции другие функции. Помещеная функция не будет вызвана пока не вызвана основная функция
  Это называется callback */

function a1() {	console.log(2);	}
function b1() {	console.log(1); 	}//нужно чтоб отработала 1й
function c1() { 	cc1 = () => {};	}//Функции ES6 созданые в обычной функции, размещаются в глобальной среде, тоесть доступ можно получить за пределами функции

/*Вызваные функции читаються справа на лево. Сначала функция смотрит что есть в аргументе, если одна функция (или последняя в списке аргументов) да ещё и вызвана, то выполнится она первой.
  Далее если есть по мимо функции ещё что-то, проверяет их и если требуется то передаёт их в тело вызванной функции для выполнения.*/
  
//Это тот вариант когда нужно вызвать функцию при этом другая функция тоже должна отрабртать. 
//Кстате говоря аргумент функции вызова можно не указывать, если нужно просто чтоб второстепенная функция отработала, не попав в функцию вызова.
a1(b1()); 


/*--------------------------------------------------------------------------------------------------------------------------------------*/
/*Работа с внешними функциями. Обычно создают внешние функции, а потом вызывают их в какой то функции, но всё зависит от обстоятельств.*/
function a2(){
	console.log("Конец");
}

function b2(a1, a2){
	console.log(a1+a2);
}

a2(b2("Функция", " b2"));//без передачи в функцию 

/*--------------------------------------------------------------------------------------------------------------------------------------*/
/*В чём отличия от вызова функции в аргументе и вызова функции в функции*/
/*ВОПРОС: Почему JS может выполнять функции которые не передал через аргумент. 
  Потому что b2 была создана в глобальной видимости и просто вызвана в локальной видимости. Все функции имеют [[Scope]] которая ведёт к глобальной видимости window
  Встаёт резонный вопрос. Зачем тогда прередавать в аргумент функцию, если её можно вызвать сразу?
  Расмотрим нюанс функции a4*/

/*Можно вызвать одну и ту же функцию локальным и глобальным способами. Локальный вызов совершаеться каждый раз вызовом функции в которой она лежит.
  Глобальный же способ подразумеваеться поместить в вызываемую функцию столько глобальных функций сколько требуеться её вызвать*/
function a3(b_3){
	b_3("В функцию b3 передали", " через аргумент");//тут скобки вызывают функцию b3 и заодно кинул аргументы
	b3("Функция b3 вызвана"," из глобального пространства");		}//функция обратилась в [[Scope]].window и нашла там b3 т.к. она была объявлена вне функции, то есть в глобальной видимости

function b3(a1, a2){
	console.log(a1+a2);
	 }

a3(b3, function()	{	b3("Функция b3 отработает", " 1й в аргументе");  }()    );
/*Безымянная функция отрабатывает не попадая внутрь. Функцию с вызывающими скобками в аргументе нельзя передать в тело функции*/

/*Что произошло в вызове? Вызваная функция a3 отрабатывает после принятия аргументов. В аргументе функция создана и вызвана (), соответственно срабатывают в 1ю очередь.
  Для такого вызова аргумент можно не указывать. Функция перередаётся без вызывающих скобок. 
  Далее функция b3 была передана и вызвана в локальной области с получением аргументов. После думаю как обойтись одним вызовом и получить от функции b3 несколько результатов, 
  что приводит в вызову функции из глобальной области. Можно это сделать несколько раз.

  Как же сделать так что бы функция переданая в локальную область функции a3, получила новые значения?
  Очевидно нужно их передать, а не вызывать в аргументе снова функцию с вызовом.*/

/*--------------------------------------------------------------------------------------------------------------------------------------*/
/*Способы передачи*/

function a4(ananimoysFunction) {	
	ananimoysFunction(); }//выполняется. Внизу я ей указал передать аргументы в функцию b4
		
function b4(a) {	
	console.log(a);		}

a4(	function ()	{	b4("Функция b4 запишется этим");  }	); //как показала практика если в прототипе функции есть вызов какой то функции, то следует передать функцию

/*Как тут работает безымянная функция. Видим по сути 3 функции. Вызванная а4, в неё переданная без вызова безымянная функция, которая содержит функцию b4 с вызовом () и передачей аргумента.
  Когда безымянная функция попадает в функцию вызова, ей для выполнения указываются скобки, а значит она начнёт выполнятся, что повлечёт выполнению функции b4*/

/*Если аргумент привязан к функции то вызвать функцию пустую не получится*/
//a4(); ошибка. Функция ananimoysFunction нуждается получить прототип функции. Она вызвана, но не определена. Определеную функцию передаём из вне
/*--------------------------------------------------------------------------------------------------------------------------------------*/
/*Кстате говоря, заметил что название аргумента имеет приоритет. Создание аргументов, это создание локальных имен. При совпадении локальных имён с глобальными, локальные 
  имеют приоритет. Это значит что если в функции будет присутствовать глобальная переменная или функция, то при указании аргументов с таким же именем назначит 
  эти функции и переменные внутри тела функций локальными и придёться передавать аргументы для них или инициализировать их внутри функции. 
  В Моём коде есть функция b3() в глобальной ветке, но при этом вызова не происходит, до тех пор пока я не отвяжу название локального аргумента, от функции или же не передам в аргумент функцию*/

function a5(a1,b2){
	console.log(a1); //норм
	b2("Какой-то текст"); //во-первых - b2 не глобальная которая у меня есть в этом уроке, а локальная т.к. аргумент имеет приоритет. Во-вторых функция не может отработать т.к. её даже не создали, тоесть это вызов, а прототипа то(каркаса так сказать)функции нет
	
}

/*Варианта 2. Или передавать созданую фунцию или создавать функцию в функции потом вызывать там же.
  Мы рассматриваем внешние создание функций и передачу внутрь других.
  Вариант с безымянной функцией*/

//безымянную можно передавать когда нужно не так много передать, т.к. описывать функцию в аргументе не очень читабельно
a5(418, function(argument1){ console.log(argument1);});//когда я вызову эту функцию в другой функии мне нужно будет передать туда аргумент что бы функция могла работать с ними

/*Подведём итоги. Закидывая в аргумент безымянную функцию, для того что бы сделать вызов этой функции в вызываемой функции. Собственно это сделано для работы с функциями из глобального списка, а так можно 
  и внутри функции создавать прототип функции и ничего не передавать*/


/*ПРО ВЛОЖЕННОСТЬ ФУНКЦИЙ*/

 /*Можно построить дерево из вложенности функций*/
// function a(a){console.log(1);}
// function b(b){console.log(2);}
// function c(c){console.log(3);}


// e( d( c() ) ); // 1 2 3 
// a( b( c() ) ); // 6 5 4    - функции выполняются с права на лево

/*--------------------------------------------------------------------------------------------------------------------------------------*/
/*Функции созданые внутри функций возвращают */
function a6(){
	console.log(11);
	
	function b6(){
		console.log(12);
		
		function c6(){
			console.log(13);
		
			
		}//c6(); 
	}b6(); //вариант вызова сразу после создани функции
}

a6();

//Что должно заставить отработать функцию b в функции a? Конечно вызов функции b. Она создаётся, но не вызвана.
/*Вариант: вызывать внутри же функции a сразу после её создания b. */

/*--------------------------------------------------------------------------------------------------------------------------------------*/
//А что если требуется вызвать функцию после передачи аргумента? Можно добавит условие

function a7(a1, a2){
	console.log(a1);
	
		function b7(){
		console.log(22);
		
			function c7(){
				console.log(23);}}

		if(a7 != undefined){	b7();	}
	//	if(a7 != undefined){	c7();	} это ошибка с7 вложена в b7
	
}

a7(21);

//Вызывая А функцию нужно получить данные из В в функции Сс функцию
      function A(callback1){
            B(callback1)
      }
A(Cc);
    
      function B(callback){
            var ddd = "Вася";
            callback(ddd);
      }

      function Cc(st){
            console.log(st);    
      }

/*Функции которые запускаються сразу */
      (function(a){console.dir(a)})(11)
      !function(b){console.dir(b)}(14);
      ((c)=>console.dir(c))(17);

/*Хочу использовать указатели не линии разделения между отсеками кода.*/
/*--------------------------------------------------(***)--------------------(***)---< На этом же отсеке--------------------*/
/*Отсек с вызовами функций*/
/*------------------------------------что-то типо---(^^^)--------------------(^^^)------------------------------------------*/
/*В этом отсеке предположим будет функция которая будет вызываться гдето наверху, это я указываю пометкой (^^^)
  Проследовав вверх по отсекам самое главное в одной траектории от этого блока мы должны встретить пометку (***)
  на нижнем уровне что говорит о том, что вызов в этом отсеке.
  Указатели от других отсеков будут находиться на другой траектории*/
/*---------------------------------------------------------------------------(^^^)------------------------------------------*/
/*Какой-то код. Вызов наверху*/
/*--------------------------------------------------------------------------------------------------------------------------*/

