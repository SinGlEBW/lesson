Для переноса gulp на новый проект нужно скопировать gulpfile.js
и package.json  далее зайти в nrm через терминал и набрать nrm up
скачаеться всё что было

#######-----CSS-----#######

Позиционирование relative относительно adsolute не работает если используеться 
относительно двух псевдо блоков.
Пример relative на before и absolute на after. Работает это только относительно родителя псевдо 
элементов.
Так же псевдо элементы инлайновые.

Before и After относительно друг друга нормально всплывают используя z-index

z-index перекрывает всего дочернего элемента со своими псевдо элементами. 
Подняться псевдо элементами за границу установленую на единицу выше чем у дочернего элемета 
не выйдет. Всплытие будет происходить только на дочернем элементе.

Что бы сделать эффект 2й тени у текста в разные стороны, нужно использовать часть 
родительского блока 

Snipets(снипеты) - это библиотеки которые помогают разработчику писать код быстрей
введя пару букв и используя tab. Emmet вроде как снипет.

Полифилы - это js бибилотеки которые напраялены на добавление новых возможностей новых браузеров старым браузерам. 
Чтоб старые браузеры понимали код написаный с использованием новых возможностей.

/*---О Функциях----*/
У функции могут быть свои методы. Сылку на них нужно устанавливать через имя самой функции.
Добавляя методы в функцию конструктор их видать только после того как функция была вызвана.
Шаблон же методов и свойств для будет известен после создания экземпляра.

Function Declaration Statement - Обычные именованные функции. 
    1) Если передать аргумент и его изменить, то в глобальной видимости это ни как не отразится.
    2) Вызывать функию можно как после инициализации функции так и перед.


Function Definition Expression - безымянная функция переданая переменной
    1) Функия не может быть вызвана до инициализации функции, но может быть вызвана в другой функции 
        даже если она выше инициализирована.
    2) Функии можно добавить имя, вызов функции этим именем не сработает это имя
       работает только в теле функции, в соновном это делают для вызова самой себя



Arrow functions - стрелочные функции
    1) Нельзя изменять значение this поэтому, не работает с bind, call, apply. this автоамтически берёться из контекста
    2) this не теряет в setTimeout и setInterval
    3) Нельзя использовать как функцию конструктор. не работает с new
    4) нету псевдомассива arguments
    5) теряет контекст в prototype сылаеться на window ... 


/*####----Факториал ----#####*/
Факториал это умножение натуральных чисел от какото то числа.
Сокршённо говорят. Файториал это (один * n)
1 * 2 * 3 * 4 * 5 и т.д до какого числа требуеться
Факториал делает циклический вызов самой себя. Число вызовов зависит от переданого числа.
Результат таких вызовов называют "ФАКТОРИАЛ ИЗ ЧИСЛА N"
Каждый цикл умножает предыдущее значение вызова на действующее.
Число 5
function fac(n) { return n < 2 ? 1 : n * fac(n - 1); };
Смысл этой формулы. Функция должна умножить число на предыдущий факториал числа, поэтому функция опять срабатывает
n! - n факториал.
Формула. Если n == 1 то 1, Если n > 1 то n * (n-1)!
Пример чиало n = 4. Подставляем    4 * (4 - 1)! = 4 * (3)!. Факториал 3х был 6(1 * 2 * 3). 
то ответ 4 * 6 = 24. 24 это факториал 4х. (1 * 2 * 3 * 4)  

5! - факториал 5 = 120
factorial(5);
1 * 1 = 1 
1 * 2 = 2
2 * 3 = 6
6 * 4 = 24
24 * 5 = 120
При этом из-за вызова функции самой себя она отрабатывает столько раз зависит от переданого значения.
Что бы получить такой же результат можно сделать цикл, но суть факториала в выполнении самой себя. При обычном цикле
функция отработает тупо 1 раз, но по сути цикл отработает также и если нужно передать работу кода

/*######------Рекурсия-------#####*/
В поиске факториала очень хорошо описываеться поняте Реукурсия это когда функция сама себя вызывает
до определёного момента и возвращает значение обратно.

Нужно хорошо понимать в рекурсии 2 вещи
    1) Как глубоко углубляться
    2) Где точка остановки







/*-------ООП--------*/
ООП придумали что бы писать большие программы и разбивать их на составляющие.
Что бы потом было проще масштабировать и менять их.
   3 принчина ООП (3 парадигмы)
1)Инкапсуляция - позволяет установить уровень доступа к элементам объекта с целью защиты
                от изменения жизнено важных свойст и методов для его работы.
                Проще говоря скрывать то что работает и не требует вмешательства постороних сил.

2)Наследование - позволяет порождать новые объекты на основе существующих.

3)Полиморфизм - позволяет дать одному объекту множество реалицаций




/*-----ГЕТОРЫ и СЕТТЕРЫ------*/
Геторы придуманы для взаимодействия со свойствами.Геттеры и сеттеры внутри классов или объектов выглядят как методы, 
при вызове ведут себя как свойства (то есть выхов совершается без скобок).
В чём же приемущество если можно по факту обратиться к свойству напрямую. В том что из-за того что внутриобъекта геттер и сеттрет
ведут себя как метод, то можно прописать логику if else как в обычной функции и к примеру задать какие-то ограничения для переопределения 
в будущем свойства.