<?php

//namespace lessonPHP;
// 1.Написаный код с ошибками может не выдать ошибок до тех пор пока нет запроса на его работу.
// 2.Пользоваться свойствами и методами материнского класса из подкласса можно, наоборот нельзя. Если нет ошибки смотри пункт 1й.
// 3.Абстрактный класс не может иметь объекта. Обращение происходить из дочернего класса.
// 4.Абстрактный метод может быть в абстрактном классе. При его объявлении он не имеет тела функции,
// заканчивается ; и обязательно должен быть объявлен в подклассе.
// 5.Не видишь смысла в абстрактном классе, удали abstract открой тело{} и задай параметры, пользы больше.



/*
 Полиморфизм - проявляеться в основном в наследовании. Это способ (свойств, методов) подстраиаваться и
 менять свои значения под определённм контекстом. Проще говоря разное поведение под разным контекстом. К примеру this->name ображаясь из разных экземпляров к этому свойству будет иметь 
 разный результат. При наследовании методов от родительского класса и обратившись к ним контекст this будет подстраиваться под дочерний 
 класс.
 
 
 Инкапсуляция - это способ скрывать свойства и методы класса которые отвечают за работу класса и не требуют вмешательства простого пользователя.

*/

function console_dir($object){
    if(is_object($object)){
        $data = [
            'className'=>get_class($object),
            'classMetods'=>get_class_methods($object),
            'classProperty'=>get_class_vars(get_class($object)),
            'propertyInstance'=>get_object_vars($object)
        ];
        foreach($data as $key=>$value){?>
            <span style="margin: 0; font-family:monospace; font-weight:bold;"><?=$key?></span>
            <h4 style="margin: 0 20px; "><?var_dump($value);?></h4><? 
        } 
    }else{
        //echo 'Переменная не является объектом.';
        var_dump($object);
    } 
}

/*------------------------------------------------------------------------*/
class Person{
    static $parentProp = 365;
    const MY_CONST = 12; //в классах определяеться так константа. за пределами классов константа определяеться через define(). что странно константы не видать в классе через разные методы get_class_vars
    public function __construct($name = '', $age = ''){
        
        $this->name = $name;
        $this->age = $age;
        $this->argumeents = func_num_args();//возвращает число кол-во аргументов переданых в функцию
        return $this->argumeents;
    }
    static function classMethod($first ='',$second=''){
        return func_get_args()[0]; //тот же самый arguments в JS. т.к. есть функция которая принимает индекс func_num_arg() какой аргумент вернуть
    }
    public function getConst(){
        return self::MY_CONST;
    }
    public function getName(){
        return $this->name;
    }
    protected function method(){//protected не видим из вне через экземпляр, но обратиться можно через методы как в родительском классе так и через дочерние.        return $this->getName();
        return self::$parentProp;
    } 
}

class Person1 extends Person
{
    public function __construct($name = '', $age = '', $city = ''){
        
        parent::__construct($name, $age); //в JS реализуеться через super()
        $this->city = $city;
    }
    public function getConst(){
        return 5;
    }
    public function value(){
        //не смотря на то что у дочернего есть этот метод мы можем изменить контекст и получать родительское значение
        return parent::getConst();
    }
    public function name(){
        return $this->getName(); //полиморфизм. метод родителя подстраивается под контекст дочернего класса. $this->name у дочернего есть так что метод отработает на дочернем элементе
    }
    public function method2(){
        //кстате если встаёт вопрос почему не parent::. действительно зная что метод находиться у родителя можно и parent. $this ищет от класса к класу нужный метод.
        return $this->method();
    }

}

$objParent = new Person('grek', 100);//кто путается. Обявление объекта это и есть "экземпляр объекта"
$dd = new Person1('pet', 26, '');

$objParent->mass = 65;//можно создавать свойства на ходу.



console_dir($objParent->classMethod(3,5,2));
console_dir($dd->method2());
console_dir($objParent->getConst());

/*
ВАЖНАЯ ИНФОРМАЦИЯ. В php так же существует понятие пространста имён как и в c++. Смысл использования namespace
заключаеться в том что бы предотвратиь встречу как минимум 2х одинаковых названий в одном файле, будь это начиная от переменной
и заканчивая классом. Предположим есть потребность подключить сторонюю бибилиотеку, а вней существует название класса 
такое же как и у нас. При попытке создать экземпляр у нас ничего не выйдет т.к. php не поймёт к какому классу нужно сылаться.

для этого в файте  где наш класс нужно указать какое-то пространство. Обычно указывают путь к файлу.
*/

//пространство задаёться в верху файла. 

require "class2.php";

$num = new ns_Class\Person(); //чтобы воспользоваться классом с другова пространства нужно указывать имя пространства через слешь. Первая мысль возникает проще класс назвать так где точно названия не совпадут чем носить за собой хвост

console_dir($num->getConst());

class_alias("ns_Class\Person", "Pson");//вот функция которая делает псевдоним класса, что бы не ворочать большим именем. 

$num2 = new ns_Class\Person();

console_dir($num2->getConst());




/*
 Основные принципы ООП.
 
    1.Подклассы могут использовать функции-методы родителя и их дополнять и переопределять значения если не
    указан параметр final на функции.
    2.Если параметр final установлен на классе, то его нельзя использовать как родителя.
    3. Свойства не могут быть помечены параметром final.
*/



// 0.Все интерфейсы не имеют объектов как и абстрактные классы. Отличие: У интерфейса все методы без тела.
// также ДЛЯ КЛАССОВ НЕ ВОЗМОЖНО ИМЕТЬ МНОЖЕСТВЕННОЕ НАСЛЕДОВАНИЕ В ОТЛИЧИЕ ОТ ИНТЕРФЕЙСОВ.
// 1.Интерфейс имеет список методов без телл{}.
// 2.Все методы интерфейса должны использованы в классе(принцип работы как в абстрактном методе абстрактного класса).
// 3.К классу можно подключать много интерфейсов перечисляя их.
// 4.Интерфейс наследует интерфейс. Вместо нескольких подключений можно подключить последний 
// с множеством наследованый интерфейсов.
interface Calc3
{
    public function calcu();
    public function cal();
}
interface Calc4 extends Calc3
{
    public function ca();
}

class Person4 implements Calc3
{
    public function calcu()
    {
        echo "ссс";
        return 5;
    }
    function cal()
    {
        echo "rr";
    }
    public function ca()
    {
        echo "tt";
    }
}

/*
    Странное явление в php callback фукнции иногда передаётся имя как строка, а не как просто имя функции,
    можно даже имя метода закинуть как callback, только т.к. это метод класса нужно закидывать и имя класса,
    отсюда и образуеться массив для передачи callback типо так: ["Person", "nameMethod"] или метод экземпляра
    [$object, "method"]. Такая передача callback действует на некоторый вид функций php.
   
    call_user_func()
*/







