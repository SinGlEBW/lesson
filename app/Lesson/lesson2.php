<?php 
/*
----------Классы Интерфейсы и Trait---------
Классы имеющие наследование могут иметь одинаковые названия функций. 
Но по поему на самом деле эти функции не имеют никакого отношения друг к другу.

Что бы использовать наследованые методы родителя в дочернем классе можно писать 2мя способами
parent::название метода или использовать всё тот же $this->название метода.
*/

/*Trait это пространство в котором можно собирать методы и свойства которые можно потом использовать в разных классах.
  Придуманно это потому что в php нет большой вложености наследования. Родитель и дочь. 
  Подключается с использованием use*/
  trait Animal {
    function myFunction1(){ echo "Horse<br>"; }
    function myFunction2(){ echo "Leon"; }
}
/*------------------------------------------------------------------ */
class Base {
    function sayHello() {
       echo 'Hello ';
    }}
   
class MyHelloWorld extends Base {
    use Animal;   //использовать пакет методов. Подключая такой пакет, $this начинает иметь отношение и к этим методам trait помимо этого класса.
       function method1(){
            $this->myFunction1();//метод взят из пространства traid
            $this->sayHello();//обращаться к методам и свойствам родителя можно указав parent::название метода
            echo 'World!<br><br>';
}}

$obj1 = new MyHelloWorld();
$obj1->method1();

echo get_class($obj1);//Функция get_class даёт возможность проверить к какому классу отнорсится объект
echo "<br>";
echo gettype($obj1)."<br>";//Функция проверяет к какому типу относится переменная
echo method_exists('MyHelloWorld', 'sayHello');//метод method_exists проверяет Существует ли метод или свойство в классе. var_dump даёт возможность увидеть булево значение. echo даёт 1 или ничего.



class A{
   public $name = 14;
 function c(){ //static зарезервирует имя и в дочернем классе нельзя будет использовать

  return $this->name;
     
    }
}
class B extends A{
    function c(){ // как угодно назвать, это не родительский метод
        echo "<br><br>";
           
     return parent::c()+2;//вот здесь действительно обращение к родительскому методу.
    }
}

$object=new B();
echo $object->c()."<br><hr>";


/*--------##-1-##--------------------------------------------------------------------*/
class M {
    static $table='table';
    static function C(){
       return self::$table;   }
}

$object1=new M();
  echo  $object1->C(); 
/*
1.Из статической функции обращаться к свойствам можно только через self::
2.Из статической функции нельзя вызвать нестатическое свойство
3.self:: не работает в нестатической функции и нестатическом свойстве
4.$this:: не работает для обращения к нестатическому свойству, только $this->
5.из нестатической функции обратиться к статическому свойству можно $this:: или self::
6.из нестатической функции обратиться к статическому свойству нельзя с помощью $this-> */

/*---------##-2-##---------------------------------------------------------------------*/

echo "<br><hr>";


class D {
    public $table='info 1';
     function C(){
       return $this->table;   }
}
class F extends D {
    public $table='info 2';

}


$object2=new F();
  echo  $object2->C(); 

/*
ВАЖНО ПОНИМАТЬ ОБРАЩЕНИЕ К КЛАССАМ ПРОИСХОДИТ ЧЕРЕЗ ДОЧЕРНИЙ К РОДИТЕЛЬСКОМУ, А НЕ НАОБОРОЬ.
ЕСЛИ МЕТОД НАХОДИТЬСЯ В ДОЧЕРНЕМ КЛАССЕ, ТО НЕТ СМЫСЛА ПЫТАТЬСЯ ЧЕРЕЗ РОДИТЕЛЬСКИЙ ОБЪЕКТ
ОБРАЩАТЬСЯ К МЕТОДУ. БУДЕТ ОШИБКА.

1.использование одних и тех же имен (как свойст так функций) в разных класса, классов связаных
  параметром extends, свойста и функции образуют единое целое и изменение приватности и 
  ключевых параметров как static, потребует изменения во всех классах.
2.не важно какого класса создан объект родительского или дочернего и так же если метод 
  один на 2 класса, находиться в родительском классе то при обращении к этому статическому 
  методу, ключевое слово self:: возьмёт информацию того свойства в классе котором находиться сам метод. 
3.с ключевым словом static:: уже есть разница объект какого класса создавать.
  т.к.через родительский класс обращаться к методам и свойствам дочернего класса нельзя, то 
  вариант один. Если нам нужно обратиться к методу родителя, через дочерний класс и если он
  указывает на свойство которое мы хотим получить, то есть 2 пути если метод статичен. 
  1й путь. обращаясь допустим к родительскому методу через объект дочернего класса мы 
  получим информацию свойств дочернего класса с помощью static::. 
  static:: так же заменяет self:: 
4.в случае если метод не статичен, а свойство статично, то доступ к свойствам через метод 
  заменяется конструкцией $this:: вместо static::
5.для нестатичных свойст и методов всё как обычно $this->

*/
?>