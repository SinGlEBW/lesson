//МЕТОДЫ Массива  push, pop, shift, unshift, split, join, slice
/*.push()  - добавляет элемент к концу массива
  .pop()   - удаляет последний элемент массива. Возвращает удалёный элемент если нужно
  .unshift() - добавляет элемент в начало массива 
  .shift() - удаляет 1й элемент массива
  .split() - разбивает строку на массивы со словами. Недостаток пробелы после слов переходят в следующий индекс. 
  .trim()  - убирает пробелы спереди и сзади текста
  .join()  - наоборот объеденяет массив в строку

//МЕТОДЫ принимающие функию
  .reduce((a1,a2,а3) =>{}) - это цикл запуска функции с перебором 2го аргумента. a1 по умолчанию всегда ссылается 
  								    на [0] индекс, а вот а2 будет изменяться столько раз, сколько имеет массив индексов. а3 принимает от массива номер индекса
  								    */
/*НЕМНОГО О ФУНКЦИЯХ. Фнкции деляться на несколько типов. Именованные и неименованые. И разница между ними заключаеться в том что именованые функции 
  создаються интерпретатором раньше, чем неименованые и это значит что порядок написания кода может быть таким, что вызвать именованную функцию можно
  раньше её объявления. Такие функции наываються declaration, а неименованые expression. 
  Есть ещё вид функций Named Function Expression(именованное функциональное выражение) это функция имеет имя и присваивается переменной. 
  Смысл в такой функции заключается в использовании её имени. Имя доступно только в самой функции что позволяет вызывать саму себя в теле функции.
  Такое использование функции применяеться в РЕКУРСИИ и факториала.*/
//Function declaration
function sum (a, b){
	return a + b;	}

//Function expression
var sum1 = function(a, b){
	return a + b;	}

//Named Function Expression - Рекурсию надо изучить
var func = function sum(a, b){
	return a + b;	}



//Создание простых объектов
var o1 = {
	name:"Robert",
	age: 37,
	city: "Flohbla"
}
console.log(o1);

var o2 = {
	name:"Villiam",
	age: 38,
	city: "Colorado"
}
console.log(o2);
//Вообщем-то код повторяется

//Создание объекта через конструктор
/*Если дать имя функции, то все созданые экзкмпляры будут сылаться на это имя и конструктору дополнительно 
  присвоиться имя, если же не дать имя то имя будет переменной в которую передали функцию 
  Имя в этой ситуации нафиг не нужно, по нему ни чё нельзя сделать*/
var PersonFunc = function () {/*функция конструктор, а значит можно создавать экзкмпляр*/ }
//вот что будет если не заполнить конструктор, придётся каждый экземпляр (объект) заполнять вручную
var obj1 = new PersonFunc();//new может создать из функции (с конкструктором) объект(typeof object)
	obj1.name = "Jack";//Ручное заполнение экземпляра obj1
	obj1.age = 31;
	obj1.city = "NewYork";
	console.log(obj1);

var obj2 = new PersonFunc();//Пустой шаблон равносильно созданию каждый раз нового объекта
	obj2.name = "James";
	obj2.age = 35;
	obj2.city = "Texas";
	console.log(obj2);//экземпляр пустой функции

/*-----------------------------------------------------------------------------------*/
//ВОПРОС: чем отличается объект созданый через функцию-конструктор и обычное создание объекта. 
/*1. Если же оставить функцию-конструктор пустой, то ничем, кроме установленного имени конструктора от которого
	  оздаются объекты, ну и присутствие дополнительного особого метода constructor который создан 
	  для работы с функцией-конструктором как с шаблоном(для удобства).
	  Заполнять придёться каждый раз, что обычный объект, что объект созданый пустым конструктором 
	  Если объетов много то придёться копировать, что создаёт много повторяющегося кода */

/*	Итог: Создать экземпляр(тип объект) может та функция которая имеет дополнительно constructor
	Проще говоря функции ES5 могут создавать объект, ES6 расчитан на работу с классами(которые по сути яввяются функциями)*/

/*ВОПРОС: Для чего создан конструктор.

	Конструктор создан для получения аргументов получения аргументов в функцию, и манипулировать в функции этими даными.
	Можно вернуть какие то даные в переменную через return, а можно положить даные в объект через this, 
	ну а объект создать через new. При обращение к даным через объект, this получает ссылку объекта, заменяя тем самым объект*/

//Использование конструктора по назначению. 1 раз создал и клепай объекты по его подобию

/*ОТСТУПЛЕНИЕ. Объект создаёться ИМЕНЕМ функции только тогда, когда функция не присвоена переменной. 
	Функция это конструктор. Имя функции или имя переменой играют роль названия класса, от которого создан объект. 
	Неименованная функция будет иметь имя той переменной к которой она присвоена. 
	Имена служат для понимания, от какого конструктора или класса создан объект*/
var PersonFun1 = function (name, age, city) {
 	this.name = name;
 	this.age = age;	
 	this.city = city;		}


var object1 = new PersonFun1("Daniel", 30, "NewYork");
	console.log(object1);//просматривая переменную с конструктором всегда увидим структуру кода функции

var object2 = new PersonFun1("Mitchel", 33, "California"); //Преимущество заполненого шаблона, обращение через constructor
	console.log(object2);

/*  Разницы в консоле никакой, но разница в коде появлятсья когда нужно создать больше одного объекта

/*-----------------------------------------------------------------------------------*/
/*ВОПРОС: 
 1.Есть ли разница между созданием метода в объекте и за его пределами
 2.Что если добавить метод обычному объекту и попробовать им пользоваться как функцией конструктором*/ 

var o3 = {
	method1:function (name, age, city){
	this.name = name; 
	this.age = age;
	this.city = city;
	},
	method2(){},//ES6 
	method3: () => {}//ES6 все новые способы вызова функций не имеют prototype и constructor
}

o3.method11 = function (name, age, city){//в разделе method отсутствует имя. Можно задать имя, оно появиться. Метод созданый вне объекта без имени через dir остаёться anonymous
	this.name = name; 
	this.age = age;
	this.city = city;
};
o3.method12 = () => {}//ES6 вне объекта стрелочная функция

console.log(o3);
/*Разницы в создании методов в объекте и вне его практически отсутствует. Отличия лишь в имени в свойстве "name": 
  Неименованные методы созданые в не объекта не имеют имени и при обращение непосредственно к ним через dir указываеться anonymous, 
  в то время как созданые в объекте, даже именованные имеют имя*/
 

/*ВОПРОС: Чем отличаеться метод от функции
	Ни чем, это и есть функция, просто она создана в каком-то объекте для выполнения задач этого объекта, поэтому принято называть такую функцию методом*/

//ВОПРОС: Как работать с прототипом
function myFunc1(){};// функция - на борту конструктор(тобишь функция конструктор)
var o_myFunc1 = new myFunc1();// объект созданый конструктором на борту тоже заимел constructor + может иметь методы добавленые в prototype
var oob = {};// обычный объект
myFunc1.prototype.myConstructor = function(){};//добавление своего метода в prototype, для дальнейшего использования на экземплярах
console.dir(myFunc1);
console.dir(o_myFunc1);
console.dir(oob);


/*И так. Функции наследуют __proto__(f) функций, которые наследуют от объектов. Так же на верхнем уровне
  выведена вкладка prototype которая может пополняться пользователем, это как вкладка полезных методов, обратившись к которым можно 
  через экземпляры объектов создаными этой функцией. В этой вкладке уже есть один метод по умолчанию constructor и опять же ссылка 
  указывающая на вкладку  __Object__ с его набором параметров. Это немного запутывает, но структура наследования не сткрыта и устроена так, что
  наследование происходит сверху вниз.*/

/*------------------------------------------------------------------------------------------*/

//ВОПРОС: Как работать с классами

/*Класс по функционалу похож на функцию - конструктор. Всё так же имееться prototype и его можно пополнять. 
  constructor теперь находится с пометкой class (название класса). Это означает что constructor вынесен в свм class
  поэтому класс создаёться без скобок () которые по факту и есть функционал конструктора, теперь они внутри класса с конструктором
  */

/*Немного о классах. Класс невидать в Глобальной ветке он занимает в [[Scope]] отдельынй раздел Script к которому имеют доступ каждая созданная функция 
  будь это ES5 или ES6. */
class ss {
	constructor(ddd, ccc){}
}

class ff extends ss{
	constructor(ddd, ccc){}
}


/*Что даёт наследование extends. Ну родительский класс наследует __proto__: от функций, а дочерние сначала, родителя с его набором 
  методов в библиотеке prototype, а потом также наследуют __proto__: для функций*/
function a(){};

ss.prototype.method_name2 = function(argument){};
a.prototype.method_name = function(argument){};
console.dir(ss);
console.dir(ff);

console.dir(a);
