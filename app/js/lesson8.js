//Запросы на сервер

/*Можно создать объект со своим функционалом, через который можем обращаться на сервер
  XMLHttpRequest наслебует XMLHttpRequestEventTarget() после EventTarget() и только после библиотеку для функций.
  На борту XMLHttpRequest в библиотеке prototype содержит кучу методов и свойств
    Например с помощью созданного объекта мы можем повесить на него события при которых получим ответ от сервера*/

/*
 Свойство
 readyState - этому свойству в экземпляре может присвоиться одно из значений описаных в функции (это состояние готовности) от 0 до 4. 
	 0 UNSET (Клиент создан. Метод open() ещё не вызван)
	 1 OPENED (Вызван метод open(). В этом состоянии можно добавлять заголовки через метод setRequestHeader(). Вызов метода send() отправит запрос )
	 2 HEADERS_RECEIVED (Вызван метод send(), получены заголовки и код ответа(200, 404, 501 и проч))
	 3 LOADING (Загрузка. Если значение responseType равно "text" или пустой строке, то responseText содержит частичные данные)
	 4 DONE (Операция завершена. Все данные получены)
Метод
open()
	1й аргумент: способ передачи запроса GET POST
	2й куда делаем запрос, URL строка  запросы можно посылать с http:// https:// , ftp:// и file://.
	3й Необязательный. true(или пусто) - асинхронный запрос, false - синхронный. 
	   Если значение false, метод send() не возвращается, пока не будет получен ответ. 
	   Если true, уведомление о получении ответа осуществляется с помощью обработчика события. 
	   Должен быть true, если аттрибут multipart равен true, иначе будет выброшено исключение.
	4й Необязательный. Имя пользователя, использующееся для аутентификации; по умолчанию имеет значение null.
	5й Необязательный. Пароль, использующийся для аутентификации; по умолчанию имеет значение null. 
xmlHttp.setRequestHeader(header, value) - может добавлен между open и send. Этот метод устанавливает значения HTTP заголовков. Несколько вызово этого метода будет дополнять заголовок
   Если заголовок не был установлен, то он будет передан в запросе со значением ( / ) когда будет вызван метод send() */

/*Помимо проверки состояния готовности нужно проверить статус что пришло с сервера.
  Статус ответа на запрос. Равен кодам HTTP (200 - успешно, 404 не найдено, 301 - перенесено навсегда).*/
  

var xmlHttp =  new XMLHttpRequest();
console.dir(XMLHttpRequest);

function myFunction(data){
	console.log(data);
}
/*Событие "При изменении состояния readyState " запустить функцию с проверкой не всегда там может быть 4 и статус 200*/
	 xmlHttp.onreadystatechange = function () {
	 	if (this.readyState == 4 && this.status == 200){
	 		console.log("Запрос отправлен - ответ получен");
	 		/*myFunction(this.responseText);*/	} }

xmlHttp.open("GET", 'http://127.1.0.0:5500/js/index.html', true);//открытие запроса
xmlHttp.send();// непосредственно отправка запроса


//Главное почему нужно событие onreadystatechange, да потому что JS код выполнит раньше чем придёт ответ с сервера и даже не смотря на то что вывод в консоль пишем после обращения запроса   
console.dir('status: ' + xmlHttp.status);//0 статус
/*
События - onloadstart: onprogress: onabort: onerror: onload: ontimeout: onloadend: onreadystatechange: 

readyState: 0 //свойство получает 4 то есть статус DONE
timeout: 0
withCredentials: false
upload: XMLHttpRequestUpload {onloadstart: null, onprogress: null, onabort: null, onerror: null, onload: null, …}
responseURL: "" //посое отправки методом send() это свойство получает ссылку куда делали запрос
status: 0
statusText: "" //при удачной отправлении свойство получает ОК
responseType: ""
response: ""  //получает содержимое запроса
responseText: "" //получает содержимое запроса
responseXML: null

*/

/*На заметку. Всё что приходит с сервера имеет type string. Если реально в полученых данных присутствуют объекты, 
  				  а у нас строка, то нужно задать им тип объекта xmlHttp1.responseType = 'json'; */


/*Для работы с промисом*/

function sendRequest(method, url, body = null){ //3й параметр добавили для обработки POST запроса. null присвоен чтоб при запросе GET не было нужды обращаться к 3му аргументу
	return new Promise( function(resolve, reject){ /*resolve, reject - это функции прототип которым нужно передать через then*/
		
		var xmlHttp1 =  new XMLHttpRequest();  //создаю объект для обращения к серверу
		xmlHttp1.open(method, url, true);	//открываю запрос

		//xmlHttp1.timeout = 4;//устанавливается время в миллисек. на подключение к серверу. Если не успевает то связь обрывается и переключаеться на событые ontimeout 
		//xmlHttp1.ontimeout = function(){console.log('Привет')};


		xmlHttp1.onload = function () {  //Вешаю событие которое будет выполняться после отправки на сервера 
		 	if (this.readyState == 4 && this.status == 200){  //делаю проверку на корректное соединение с сервером
				resolve(xmlHttp1.responseText)	}   //т.к. этот раздел у нас подразумевает положительный результат, то вызов функции resolve цепляем сюда
				
					else{ reject('Ошибка')	}	}      //здесь если с сервером не связались. вызов функции reject.  потом привяжем её прототип к методу catch()
		
		
		/*Заголовок нужен для того что бы сервер понимал как обрабатывать отправленый запрос */
		xmlHttp1.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");//заголовок отсылается как GET так и POST. Указывается обязательно.
		xmlHttp1.send(body);// send() - имеет один параметр "body" и он работает только с POST. В методе GET все параметры передаються в адресной строке, а в методе POST в теле запроса собственно в send()
		//xmlHttp1.abort(); // не смотря на то что метод стоит после send этот метод отменяет запрос на сервер
})			}

var res = ["tt","ddd"];//запросы передавать нужно ключ, значение.
var arr = JSON.stringify(res);

var dataBase = 'd=' + "f" ; //готовлю данные для обработки на php. Вариант создания ассоциативного массива для php
sendRequest("POST", 'http://localhost/Lesson/new.php', dataBase)
		.then( (data)=>{ console.log(data); } )
		.catch( (error)=>{ console.log(error); } )











/*Same Origin Policy - ограничения безопасности. Запрос со страницы можно отправлять только на тот же протокол://домен:порт, с которого она пришла.
  Если отсылать запрос на другой домен, то должен быть доступ к тому домену что бы послать запрос на сервер header('Access-Control-Allow-Origin: *');
Насколько важно передавать заголовки.
Допустимыми значениями заголовка Content-Type являются:
application/x-www-form-urlencoded - даёт возможность передавать на сервер текст

multipart/form-data - этот заголовок передавать файлы
text/plain
*/


/*~ побитовое отрицание. Положительное конвентирует в отрицательное и наоборот. Отрицательное на 1 всегда больше,
    Выводить наоборот то положительное на 1 меньше будет
*/
let aa = 5;
console.dir(~aa);
