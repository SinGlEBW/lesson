
/*
    Что бы понять что должен делать 1й цикл нужно обратить внимание на то сколько раз должен запуститься 2й цикл.
    отсюда и возникает шаг по циклу. 2й цикл выполняет что-то с куском массива этого шага который мы задали.
    3я задача это настроить 2й цикл что бы он не крутился на одном и том же шаге, а работал с каждым заданым шагом 1го цикла.  
*/
let arr = ['вася', 19, 'петя', 40, 'елена', 35, 'юлия', 30, 'жора', 25];//отсюда

let arr1 = [];//базируем сюда.
let j = 0;//счётчик с шагом в 1 для 2го цикла. потому что в цикле дальше 1цы не уходит. Это и есть настройка 3я задача.
for(let i = 2; i < arr.length + 2; i+=2){
    let array = [];
    for(;j < i; j++)
        array.push(arr[j]);    
    arr1.push(array); 
  
}
console.dir(arr1);
/*
[['вася', 19], ['петя', 40],['елена', 35,],['юлия', 30],['жора', 25]];  вариант сделать так


*/

/*
 Iterator. есть такие специальные сущности которые можно перебирать только через for of
    в new FormData выдаётся именно аткой итератор
*/
/* Со временем я понял что не всегда удобно использовать функциональный цикл т.к. приходиться иногда работать с Promise 
    и async должна быть внешняя функция
*/

function data(req, res, next) {
    registerValid.forEach(async(item) => {
      await item(req, res, next)//async и await работают только на одной функции 
    })

    let errors =  validationResult(req);//пусто
    console.dir(errors);
}

async function data(req, res, next) {
    for(let item of registerValid){
      await item(req, res, next)
    }

    let errors =  validationResult(req);//не пусто
    console.dir(errors);
}
