let arr = ['1','2','3'];
let [one, two, three] = arr; //масисв рабрасывает значения по переменным. Смахивает на Spread.
//только в функции нельзя провернуть такой трюк (a, ,c), а тут можно.
let [a = 4,b,c] = [,5,7];//если передать переменной a, то её значение перезапишет новым.
//можно поменять местами значения
[b,c] = [c,b];//берём переменные в деструктуризацию и берём теже переменные помещаем в массив нужным нам образом.

//для работы с объектами деструктуризация использует скобки подобно объекту.
let obj = {mass: 100, s: true};
let {m,s} = obj;//передавать можно только объект.
console.dir(m);//undefined т.к. такого свойства нет в переданном объекте
console.dir(s);//нормально пердача значения состоялась
/*
    Деструктурированый объект копирует значения свойст переданного объекта и передаёт их в обычные переменные названные этими свойствами иначе передачи не будет.
    Это и есть отличие от декструктуризации массива в переменные. Там переменные можно называть как угодно.
*/

let {v,n} = {v: 200, n: 300}; // let v,n; ({v,n} = {v: 200, n: 300}); ещё такой вариант, но он чёт очень
console.dir(v);

/*
    И так вот значение то передали, а имя то переменной нас теперь неустраивает т.к. оно являеться именем свойства
    Нет бы дать возможность сразу передавать в нужное нам имя, так приходиться назначать новое имя через 
    : ,буд-то мы свойству назначаем имя. Конечно можно не заморачиваться а использовать имя свойства.  
*/ 
let obj1 = {d: 70, r: 35};
let {d: foo, r} = obj1;//кстате d или же теперь foo - это не ссылка.
console.dir(foo);//задали новое имя свойству по 
foo = 14;
console.dir(foo);
console.dir(obj1.d); //теже 70 т.к. не ссылка, а копия.

let obj2 = {id: 42, name: 'jakov'}
let {id = 3, age = 18} = obj2;// назначить значения по умолчанию, но они переюиваються передавая объект

console.dir(obj2.age);


function name(...a){//rest - собирает значения в один массив

}

function name2(a,b,c){
    console.dir(a);
    console.dir(b);
    console.dir(c);
}
name2(...arr);//spread - разбрасывает массив