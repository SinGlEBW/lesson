//Использование метода класс лист.
var wrapParent = document.querySelector('#wrap');
//classList - принимает список методов из __proto__: DOMTokenList;

wrapParent.classList
console.dir(wrapParent.classList);

//Обработка события
wrapParent.addEventListener('click', callback);
//click - наследует __proto__: MouseEvent
function callback(even) {
	console.log(even);}

let a = [2, 4, 6, 7];
function myFunc(a){
	for(let i = 1; i < arguments.length; i++){
		let num = arguments[i];
		if(a.indexOf(num) === -1){
			return false;//если числа нет, то ошибка -1
		}	}
	return true;}

console.log(myFunc(a,2,4,7));
/*ОПИСАНИЕ.arguments содуржит все передаваемые аргументы в функцию, даже если их было переданно лишку
  Что бы аргументы перебрать использую станд. схему. Далее идёт вся суть кипеша
  Можно сравнить соответствие и положение чисел масива и чисел которые набросаны дополнительными аргументами
  Что делает indexOf - принимает искомое значение и ищет его метоположение.
  Результатом будет число полученное в результате сравнения точки его положение и начальной точки. 
  Результаты -1 если ничего не найдено, 0 если разницы между искомой строкой и точкой отсчёта не было. 
  Если же строка или значение были в где-то далеко от точки подсчёта, indexOf вернёт подсчитанное значение. */

//Обработка функций её методами call, bind, apply.
/*Один из вариантов создания этих методов вызвала работа с псевдо объекто this
  this это сущность которая получает ссылки на объекты, в дальнейшем через 
  эту сущность можно обращаться к объекту. 
  Как это происходит? Как this понимает какой объект передал ей ссылку. 
  Как пользователю понять что this привязанна к нужному объетку?
  Просто. this используют обычно в методах, которые относяться к объектам, а значит
  и this тоже относиться к тому объекту*/
  
	var person = {//this ссылается на этот объект
		 name: 'lion',
		 age: 21,
	  //   fullP: function(a1, a2){
			// this.n_a = (`${a1} ${a2}`);
			// console.log(this.n_a);}
			 } 

	var person2 = {
		 name: 'Elena',
		 age: 22
	}

function fullP2(a1, a2) {
		this.n_a = (`${a1} ${a2}`);
		console.log(this);
//в один момент времени this принадлежит одному объекту, в другой момент другому. Универсальная функция становится с объектом this
}
/*Можно ли поделится методом(или функцией) для другова объекта? this в методе 
  ссылается на объект в котором находится. Способ через метод bind*/

fullP2.bind(person, 'вася', 45)();
fullP2.bind(person2, 'a', 11)();
/*откуда взялись 2е скобки. FullP это функция с скобками. Есть много методов при обращении к ним они автоматически ещё и вызывают
  функцию, поэтому после обращения к методам не приходиться дублировать скобки. Метод же bind не вызывает функцию*/

//МЕТОД call() и apply()

fullP2.call(person2, 'a', 11); //call с автовызовом функции. а2 может быть функцией
fullP2.apply(person2, ['a', 11]);//2й параметр всегда массив

function myFunc2(arr, n) {
	return arr.map(function(i){
		return i * n;})
	}
	

	

console.log(myFunc2(a, 3));



let em = {
    name: 'Hanna',
    position: 'junior',
    salary: 1000
}
let em1 = {
    name: 'Petr',
    position: 'junior',
    salary: 1000
}

function increase( newPosition, newSalary){  
    this.position = newPosition;
    this.salary = newSalary;  
  
}


//обычные экземпляры. this(означает Контекст) отноститься к своим экземплярам
//контекст означает к кому будет принаджедать this. эеземпляру объекта.
let a = new increase('middle', 2000); 
let b = new increase('junga', 200); 
//можно не только создавать экземаляр, можно изменять часть объектов 
increase.call(em,'junga', 200); 
 /*
 bind call apply в этих функциях контекст передавать 
 нужно только тогда когдга используеться this в остальных случаях ставить null
*/

 /*########-----что такое коррирование-----######### */
 /* 
 Это когда функция принимает кучу аргументов обрабатывает и возвращает значения 
 */

function brick(w, h, m){
	return w + h + m;
}
let a3 = brick(1, 2, 3);
let b3 = brick(1, 2, 5);
let c3 = brick(1, 2, 9);
/*
из-за того что параметрв поаторчются можно не писать их каждый раз а воспользоваться
каррированием.
Отличие bind от call и apply в том что bind не сразу передаёт парамерты объектам в определённом
контексте, а для начала подготавливается и создаёться другая копия метода, для дайльнейшей передачи
параметров в определённом контексте.
Отсюда и рождаеться идея коррирования. Когда функцию, которая принимает кучу параметров,
подготавливают таким образом чтобы однотипные параменты передать оди раз, а оставшиеся принимать
по одному 
*/
let newBrick = brick.bind(null, 1, 2);//1й аргумент установка контекста, которого нет в функции поэтому null
let d3 = newBrick(7);
let e3 = newBrick(6);
let f3 = newBrick(15);
// console.dir(f3);

//2й способ. Имитация bind

function a4(width){

    function b4(length){

        function c4(height){
            return width + length + height;

        }return c4;

    }return b4;

}
let b4 = a4(15);
let c4 = b4(10);
console.dir(c4(15));
//или же можно вызвать всю вложенность вот так
let e4 = a4(5)(10)(20)
console.dir(e4);

