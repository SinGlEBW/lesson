 //Создание объекта. синтаксис похож на css.Описание статичных свойств
 
 const s1 = Symbol('debug');
    const s2 = Symbol('debug');
    console.dir(s1 == s2);
    const obj = {};
    let cc = 11;
    let str = 'string';
    obj[str] = 'какая-то строка';

    obj[s1] = 'value Symbols';
    obj.s1 = 'строка';

    obj[cc] = 14;//тут используем значение переменной сс в качестве имени. Там число JS решает закинуть его в кавычки
    obj.cc = 15;

    /*
        Из-за того что каждый инициализированый тип Symbol инливидуален, то ничего не мешает создать ещё один тип symbol
        с тем же ключем и добавить его в объект. С обычными типами не получиться добавить 2 одинаковых свойства.
        Такой подходу нужен при работе с разными библиотеками, где есть вероятность моздать объект в котором имена свойст могут конфликтовать
    */
    obj[s2] = 'value Symbol 2';

 console.dir(obj);
 console.dir(obj[11]);//т.к. число было передано в качестве имени для свойства, то обратиться можем только через число или имя переменно и ТОЛЬКО ЧЕРЕЗ СКОБКИ
 console.dir(obj[cc]);//один и тот же результат
 console.dir(obj.cc);//совершенно другая конструкция и никакого отношения к [cc] не имеет. Просто свойство добавлено через точку

 console.dir(obj['debug']);//через результат типа Symbol до значения свойства не достучаться. Так Symbol('debug') тож не катит
 console.dir(obj[s1]);//получаем значение, но для этого нам нужн этот ключ s1, поэтому это сичтаеться СКРЫТЫМ СВОЙСТВОМ, без ключа его не получить
 console.dir(obj.s1);//тож самое. никакого отношения к [s1] не имеет
 
 console.dir(obj[str]);//используя имя в качестве переменной, то и свойсто будет называеться его значением и доступ совершать можно как через значение так и через имя и ТОЛЬКО ЧЕРЕХ СКОБКИ
 console.dir(obj['string']);//тут JS решил убрать скобки в названии свойства.
 console.dir(obj.string);//вот тут единственый случай когда объявленная строка в [] стала именем свойства по которому можем обратиться1
 
/*
    Использование Symbol в объектном литерале требует заключать тип в [] т.к. нам нужно значение переменной, а не переменная
*/
   let obj1 = {
    [s1]: 44,//тип Symbol
    s1: 55,//обычное свойство
    '14': 17//целочисленное свойство. это свойство которое может конвертироваться в число и обратно без изменений
}
console.dir(obj1);
 
 /*----------------------------------------------------------------------- */
 //способ 1. безымянный объект
let A = {
    w:10
  }
  //способ 2. безымянный объект. конструктор функция потом только объект
  let B = new function(){
    this.w = 10
  }
  //способ 3. именованный объект. ES6 классы. есть свой конструктор потом ссылается на объект
  
  class C{
    w = 10
  }
 
 
 
 let person = {
     name: 'Толян',
     age: '21',
     color: 'red',
     //Создание функции метода внутри объекта
     /*Оказывается переменные в методе не имеют никакого отношения к статичным свойствам выше. Их можно назвать как угодно. 
     	this.название переменной это и есть инициализация новой переменной свойства*/
     Method1: function (a1, a2, a3) {//теряется this
         this.name = a1;
         this.age = a2;
         this.city = a3;
     }
 }


 /*
 Создавать функции методы, можно вне объекта. Название можно давать на ходу. Методом считаеться та функция, которая вызываеться через объект.
 person.newMethod = function(a1, a2, a3){описание} // это инициализация функции метода для объекта
 */

 //---------------- Вывод статичных свойств--------------- 
 //Задание 1: Разобраться как при помощи вызова функции показать информацию всех статичных свойств.
 //Вариант 1.
 /*
 function nameFunction1() 
 {
 	console.log(person.name + '\n' + person.age + '\n' + person.color)
 }
 nameFunction1();
 */
 //А если свойства меняються динамически? Каждый раз забивать свойства вручную? Есть другой способ решить данную проблему и без повторений кода
 //Вариант 2. Выбор способа создания функции. Можно создать функицю безымянную и присвоить её переменной let nameFunction2 = function(){описание}
 //Я предпочитаю по старинке.
 function nameFunction2() {
     for (let n in person) { //ключи свойст преобразуютсья в строку

         switch (typeof person[n]) { //убираем лишний показ методов. нам нужны только свойства. приходиться создавать условие.
             case "function":
                 break;
             default:
                 console.log(person[n]);
         }
     }
 }

 nameFunction2();
 /* Почему person[n] использование квадратных скобок. Есть обращение к свойству обекта person['название свойства или метода']. 
    так вот цикл for in добавляет каждому полученому свойству или методу кавычки '' автоматически. Хотя через console.log(n) этого нет.
 	Поэтому такое написание person.n  не уместно т.к. нет такого синтаксиса person.'name' .... */

 //-------Разбор методов объекта и воздействие на свойства----

 /*Что мы имеем свойства в объекта которые можно менять обращаясь по отдельности и метод в объекте который живёт сам по себе со 
   своими свойствами. Допустим я хочу создавать объекты индивидуальные. Присваивая статичные свойства объекта, другим переменым 
   (выступающим как индивидуальный объект) Пример: let p1 = person; p1.name = 'Вася'; Смысла в этом мало.Изменяя p1, person.name перезапишется. 
   Вообщем-то если писать послеовательный код то это может сработать, всем объектам можно заменять значения свойств.
   Код получиться грамозким и прерастёт в копипаст. Куча объектов - куча копипаста. 


 /*С p3 дела обстоят не корректно. p3 - объект, но не построена связь к свойствам. Для обращения к свойствам и методам 
   (когда объявляеться объект с помощью new - это указывает на динаическую память) невозможна без ключевого слова this
   Такая функция называеться Конструктор объекта. Тот же шаблон, но не требует return т.к. обращение происхдит к отдельным элементам свойств*/
 function newFunction4(a1, a2, a3) {
     this.name = a1;
     this.age = a2;
     this.city = a3;
 }

 p4 = new newFunction4('Андрей', 40, 'Шуя');
 p5 = new newFunction4('Слава', 30, 'Ярославль');
 console.log(p4.name);
 /*Что происходит в этой ситуации. Эта функция создана верно, но из-за имени выдаёт ошибку т.к. Это не создание метода объекта person

 function person(a1, a2, a3){
 	this.name = a1;
 	this.age = a2;
 	this.city = a3;
 }

 p6 = new person('Андрей', 40, 'Шуя'); //как только происходит вызов.Вызыват ошибку
 */

 person.Method1('Григорий', 27, 'Кинешма');
 console.log(person.name);
 console.log(person.city);

 /*
 Я полагаю переменные в методе не имеют никакого отношения к статичным свойствам выше. Их можно назвать как угодно. 
 this.название переменной это и есть инициализация новой переменной свойства. 

 Важно:  все переменные являются общими в объекте person. 
 При вызове метода в котором есть некие переменные они инициализируются. Приоритет у переменных в  методе выше. 
 Если встречаются одинаковые идентификаторы, то идентификаторы свойств объекта не вызываются и хранятся 
 где-то в памяти.При обнулении значения в переменной(свойства) метода. Возвращается значение свойства объекта.*/



