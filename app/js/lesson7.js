/*Неименованые функции в основном закидывают в аргумент что бы их вызвать в вызваной функции и как правило на борту неименованой функции присутвтвует вызов другой функции
  в которую передают аргументы. Такое решение принято потому что нужно передать аргументы той функции которую несёт безымянная функция т.к. аргументы не передать сразу */


//Фукция setTimeout делает вызов функции через определённое время
/*Пример из интернета. Тема Промисы*/

// function app(documents, resolve, reject){
// 	console.log("Обработка заявления...");
	
// 	setTimeout(		function() { Math.random() > .5 ? resolve(documents) : reject("В визе отказано") },		2000);
// }

// function bookHotel(){}//
// function buyTickets(){}


// app(
// 	{}, 	
// 	function(visa){ console.log("Виза получена"); 
// 						 bookHotel(visa, 
// 						 			  function(reservation){buyTickets( reservation, function(){}, function(){}) },
// 						 			  function(error){} )},
// 	function(reason){console.error(reason);}
// 	)

		
// -------------------------------------------------------------------------------------------------------------------------------------
/*Стрелочная функция*/
// add = (documents, resolveAnon, rejectAnon) =>{
// 	console.log("Обработка заявления...");
// 	setTimeout(	() => { Math.random() > .5 ? resolveAnon(documents) : rejectAnon("В визе отказано") },
// 					2000);
// }

// bookHotel1 = () => {};
// buyTickets1 = () => {};

// add(
// 	{}, 	
// 	(visa) =>{ console.log("Виза получена");    //присвоиться resolveAnon которая передаст document
// 				  bookHotel1(visa, (reservation)=>{  buyTickets1  },(error)=>{} )
// 		},
// 	(error)=>{console.error(error);}//присвоиться rejectAnon
// 	)



/*Вызывая функцию add она принимает 3 аргумента. Ничео не возвращает. Функция setTimeout вызовет безымяную функцию через 2 секунды, в которой имееться условие
  который делает ставку на вызов одной из 2х функций, но прежде чем их вызвать они нужнаються связаться с прототипами функций что бы знать что делать.
  Мы передаём объект и передаём 2 прототипа безымяных функций, которые отработают в функции вызова. Одна функция несёт положительный результат
  после того как безымянная функция вызовется в её теле указано сообщение и вызов глобальной функции в которую нужно передать полученый объект*/


/*ВОПРОС: Что такое Promises(Промисы)
  Промисы нужны что бы код был более читабельным. Если требуеться очень много вкладывать функции в функции, то промисы вроде как более удобно это исполняют*/




// app = (documents) =>{
// 	console.log("Обработка заявления...");
	
// 	let promise = new Promise((resolveAnon, rejectAnon) =>{  setTimeout(	() => { Math.random() > .5 ? resolveAnon(documents) : rejectAnon("В визе отказано") },
// 																								2000);})
// 	return promise;
// }

// bookHotel2 = () => {	 console.log('Бронируем отель');	 }
// buyTickets2 = () => {  console.log('Покупаем билеты');	}

// app( {} )
// 	.then((visa) => {	 console.log('Виза получена');	})
// 	.then(bookHotel2)
// 	.then(buyTickets2)
// 	.catch((error) => {	console.error(error);  })


/*Что хотим от кода. Вызвать функцию которая будет выполнять одну из функций в зависимости от рандома в 50%. */

/*Мой вариант*/
// att = (documents) => {
// 	console.log('Обработка заявления..');
// 	setTimeout(() => {if(documents && Math.random()> 0.5){
// 		console.log('Виза получена');
// 		bookH = (documentsVisa) =>{	console.log('Бронируем отель'); buyT = (documentsVisa) =>{  console.log('Покупаем билеты'); buyT(documentsVisa) } 	}
// 		bookH(documents);

// 	}else{console.error('В визе отказано: Недостаточно документов');}}, 2000)
	
// }

// att({});



/*Безымянные функции передавать можно только в аргумент. В остальных случаях функция должна сожержать имя своё или переменной*/

/*В это приёме использую ещё и замыкание. Получив значение в вызываемую функцию отдаю его во внутренюю функцию*/

 function aa(a1){
				function bb(){	console.log(a1); };
	 return 	function cc(){ return a1; } //Просто созданая функция без вызова. Вызвать можно как снаружи так и внутри		
}


console.log(  aa(1)()	);//return вернул функцию, добавив скобки можем её вызвать
/*Что тут происходит. Вызванная функция отрабатывает и возвращает какой то результат. Если возвращает функцию то квызывающей функции добавляем скобки для вызова 
  возвращаемой функции. Это получаеться внутренюю функцию вызываем снаружи.*/



function a(){
	return function b(){
		return function c(){ 
			return function d(){ return 'Привет';}
		}
	}
}

console.dir(	a()()()()	); //вложеность функций можно получать return(ом) и вызывать добавляя скобки

var cc = function(a1,a2){	console.log('Вася');};


function aaa(){	console.log('Тект1. Функция aaa');	}
function bbb(){	console.log('Тект2. Функция bbb');	}
function ccc(){	console.log('Тект3. Функция ccc');	}


var promis = new Promise(cc);

console.dir(promis);
console.dir(Promise);

/*Разница вызова в аргументе или внутри функции состоит в том, если трубется какое-то взаимодействие функций, то вызов совершают внутри*/

/*Задача стоит сделать мини програмку из функции которая будет возвращать результат одной из функций*/
/*Как вызывать безымянные функции. Можно передать переменной и потом её вызвать, а можно вызвать без переменной*/
var nameFunction = function(){	console.log(1);	}(); //добавив скобки происходит сразу вызов функции

//мы знаем что безымянные функции не имея имени прекрасно чувствуют себя в скобках, но без скобок требует обязательного присвоения.
(function (){	console.log(2)}	)();//добавив к такой конструкции скобки мы собственно вызываем функцию. Такой конструкцией часто пользуются. Самовызывающая функция 



/*Экземпляр объекта наследует __proto__ "Здесь название той функции конструктора" от которой создан объект.  __proto__ это prototype конструктора от которого создан объект, ну и далеее имееться наследование */




