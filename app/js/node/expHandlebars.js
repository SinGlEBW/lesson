const hbs = require('express-handlebars') //engine принимает это название
const handlebars = require('handlebars');
//handlebars.registerPartial()
const express = require('express');
const path = require('path');

let pathFiles = path.join(__dirname, '../../');

let app = express();

/*
  В helpers можно создавать 2 типа помошников. 
  1й это просто обычный вызов {{название метода}}
  2й уже с решёткой {{#название}}
  как я понял такие методы нужны для выполнения неких действий в пространстве между открытием и закрытием метода
  {{#мой метод}}
    ....
  {{/мой метод}}
  При создании такого метода имееться 2й параметр options с методом fn, куда можно перечислять получаемые значения 
  помещая их в объект задав имя через которое в дальнейшем можно будет обращаться и так же помещать свои
  параметры которые будут иметь общий доступ
  Не уверен, но вроде после фиксации в options.fn() параметры могут использоваться через стандартные
  помошники. До этого не работают с ними.
  В любом случае все значения которые требуеться выводить нужно регистрировать в options

  
*/


let page = ['Главная', 'Контакты', 'Информация', 'Доставка', 'Акции'];
const newHbs = hbs.create({
  layoutsDir: 'handlebars/layouts', //млжно было не указывать т.к. папка handlebars установлена в set, а layouts автоматически ищется
  defaultLayout: 'index',
  extname: 'hbs', //формат подключаемых файлов тоже будет таким
  helpers: { //в этом разделе можно создавать свои методы которые потом можно вызывать

    link: (value, options) => options.fn({page: page}) , 

  },
})

app.listen(3000);

app.engine('hbs', newHbs.engine) //newHbs.engine возвращает function bound как и вызов hbs({options})

app.set('views', './handlebars') //путь папки где лежат подключаемые шаблоны
app.set('view engine', 'hbs') //тут подключаю это событие с настройками. 

//handlebars.registerPartials(__dirname + "/handlebars/partials");

/*
hbs.registerPartials(__dirname + "/views/partials"); - много где указано регистрировать
но это не та версия это какой-то сторонний hbs
*/


app.use((express.static(pathFiles)));

app.get('/', (req, res) => {
  res.render('home', {

    obj: {
      lin: ['Значение 1', 'Значение 2', 'Значение 3', 'Значение 4', 'Значение 5'],
      people: {
        name: 'вася',
        family: 'пупкин',
        age: 26
      },
    },
    car: {
      Germany: 'Audi',
      Shvetsii: 'Volvo',
      Frantsii: 'Bugatti'
    },
    arr: [453, 75, 23, 48],
    title: 'Главная',
    header: 'просто текст',
    helpers: {},

    check: false
  })
})

app.get('/lk(.html)?', (req, res) => {
  console.dir(req.url);
  res.render('lk', {
    car: {
      Germany: 'Audi',
      Shvetsii: 'Volvo',
      Frantsii: 'Bugatti'
    },
    arr: [539, 75565, 2783, 478],
    title: 'Личный кабинет',
    header: 'просто текст',
    helpers: {}
  })
})

// app.get('/css/s/lesson.css', (req, res) => {
//   res.sendFile(`${pathFiles}/css/lesson.css`)
// })

/*
  О месте расположения файлов. В чём собственно путаница. Обычно для всех ссылок и  подключаемых файлов путь устанавливают
  относительно страницы index, но индекс по факту может находиться совсем не в корневой папке. Желательно конечноеё забрасывать 
  в корневой каталог.
  Если index находиться не в корневом каталоге, то 
   - во первых все отступления не запросом не будут видны типо ../../../css/style.css,
  запрос считаеться от последнего слеша перед которым начинаються буквы адреса.
   - во вторых это всего лишь запрос, по которому мы можем передать всё что угодно и не обязательно конкретный файл с конкретного
  места.
  Но что бы не возникало путаницы лучше стараться держать файлы там файлы структурировано и посылать их по логичным запросам.

  И так мы выяснили что запросы это тот ядрес по которому мы хотим получить что-то и строим мы их удобным для себя образом в GET
  запросе.

  Теперь есть понятие настроящее местоположение файлов с которыми нам нужно работать. Работа может заключаться относительно серверного файла, 
  что не во всех случаях работает и приходиться писать абсалютный путь.
  
  В разных фреймворках по разному осуществляеться работа с ними. В express можно указать сразу
  корневую папку и все запросы которые вроде как фейковые на которые мы подкидывали с других районов
  файлы становяться не фейковыми. Теперь мы мл========================


    Может придти запрос
*/

/*
Layout (макеты) - файлы к которым подключаються свойства и ' частичные представления' (общие маленькие куски Html кода)

Если директория с шаблонами(макетами) не задана явно, то поиск 'представлений' по умолчанию будет 
осуществляться в директории views, а главного макета 'мастер страницы' - в views/layouts.
Как я понимаю достаточно одного макета index куда будут подключаться 'представления' и 'частичные представления'

Вариант 1й как делают
  один файл Layout в котором будет тупо меняться куски кода в body. 
  Всякие navigation, section, footer. По факту имеет одну страницу с hedarom
  Кладут в папку layout, далее указывают в настройках этот файл и в последующем 
  при запросах направляют туда данные



  Вообщем и целом запутанная дичь. При обращении к / мы по факту рендерим что-то в index который вызываеться за кулисами
  и что бы это отобразить в index нужно указать такую запись {{{body}}} что очень странно, потому что при построении
  сайта немного другим принципом такая запись из 3х {{{ }}} помойму работает немного не верно, но это я ещё проверю

  Что мы имеем по факту. 
  одна страница index.hbs в папке layout на которую передаються при запросах
  разные страницы. Так же мы имеет папку partials в которой храним общие куски кода (называевыми частичные представления)
  их мы подключаем на разных страницах. по умолчанию они ищуться в views
  Что удивительно подключая к одной странице мы на неё не трогаем шапку сайта, а подключаем только в body
  
  По поводу получения свойст. Использовать двойные или тройные фигурные скобки, зависит от того какой мы выводим текст.
  Если мы в JS пишем html код к которому хотим потом обратиться то используем 3 {{{ }}} они конвертируют html код 
  если использовать в таком случае двойные {{ }} то html экранируеться
  Всякие циклы, условия и подключения через 2 {{ }}
  
  Как расчитывал я.
  Вызывая каждую страницу по отдельности имея так же подключеные общие куски кода
  Честно не знаю насколько выгодно отображать на один layout файл.
  Так же я предполагал вырезать шапку, а потом её везде подключать.
  Мне бы пришлось на каждой странице дополнительно устанавливать header, а теперь мне впринципе его трогать не нужно.
  если 
  То есть это выходят загружая каждую страницу к ним подключаем все файлы папки 
  partials.Сейчас я экономлю на создании лишних файлов, насчёт подключений пока не ясно один раз
  загружаеться css или каждый раз по новой


  указвы layout: false, мы рендерим то что хотели передть в Index сразу на экран, тоесть то что рендерим
  можем подготовить как отдельную страницу без всяких layoutov, но так получиться
*/



/*
  Так же не знаю что это значит, но handlebars может следить за кешированием страницы если эту функцию включить
*/

/*
    Если имя локально определенной вспомогательной функции совпадает с глобальной,
    то в представлении, где описана локальная, будет использоваться локальная.
*/