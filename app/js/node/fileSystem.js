let fs = require('fs');//fs - FileSystem
let path = require('path');
let filePath = path.join(__dirname, 'test', 'text.txt');

/*
* ##########-----Создание, удаление, просмотрт - директорй, файлв-----########### 
*/

//fs.mkdir("test",(err)=>{// - создаёт папку. имя папки относительно данного файла
//   console.dir(err);
//});
//fs.mkdirSync('./tt');

// Если папка не пуста то удаление не пройдёт пока не будут удалены файлы
//  fs.rmdir('./tt',(err)=>{//удаление папки.
//      console.dir(err);
//  })
//fs.rmdirSync('./tt');

// fs.unlink('./test/t.txt', (...err)=>{//удаляет только файлы
//     console.dir(err);
// });

//fs.unlinkSync('./test/t.txt');//синхронный вариант


fs.readdir('./test', (err, file)=>{
   
})
let files = fs.readdirSync('./test');

let status = fs.statSync('./test/gg.txt');//получаем объект с информацией о файле
console.dir(status);





fs.existsSync('/test');//если требуеться проверить наличие файла. bool

/*
* ##########-----Открытие файла-----###########  
*/

//методы работают немного иначе чем в php. ничего не возвращают я такт понял
// fs.open("test/text.txt","w+", (err,fd)=>{//тупо открывает файл. fd - файл дескриптор
//  console.dir(fd);
//     fs.close(fd,(err)=>{//для закрытия передаёться дескриптор
//         //console.dir(err);
//     })
// })

/*
Вся таже самая херня как в php
r+ — открыть файл для чтения и для записи. Курсор в начале. Перезатирает, пишет прямо по тексту изменяя его.
w - перезатирает. w+ тоже
w+ — открыть файл для чтения и для записи, установив указатель потока в начало файла. Если файл не существует — он создаётся.
a — открыть файл для записи, установив указатель потока в конец файла. Если файл не существует — он создаётся.
a+ — открыть файл для чтения и записи, установив указатель потока в конец файла. Если файл не существует — он создаётся.


/*ВАЖНО. Функции с суффикксом Sync вроде удобней, но работают они синхронно, это значит что выполнение
         кода ниже не начнёться пока эта функция не отработает. Это не всегда уместно. Нужно смотреть по ситуации
*/

fs.opendir('test',(err, Dir)=>{//тупо открывает папку
  //  console.dir(Dir);
  
})


/*
* ##########----Запись в файл-----###########
*/
let content = "Пока";
/*
    При непонятных обстоятельствах write() может записать не весь буфур, а только часть, в то время как
    writeFile() будет пытаться записывать до тех пор пока не запишет всё или выведет ошибку, да и вообще непонятно
    как пользоваться write и writeSync
*/
//fs.writeFile(): записывает данные в файл. Похожий метод: fs.write().
// fs.writeFile(filePath, content, {encoding: "UTF-8", flag: "a+"}, (err)=>{
//     console.dir(err);
// });


//fs.writeFileSync('./test/text.txt', content, {flag: 'a+'});//как вариант
/*
ВАЖНО. Можно указывать URL, но для этого требуеться как я понял создать объект
let fileUrl = new URL('https://user:pass@sub.example.com:8080/p/a/t/h?query=string#hash');   
//есть аналог. Удобен тем что не нужно указывать доп параметры для добавления текста к имеющимуся
 fs.appendFile(filePath, "\nГригорий", (err)=>{
     console.dir(err);
 });

*/
/*
* ##########-----Прочтение файла-----########### 
*/
// fs.readFile('./test/text.txt', "utf8", (err, content)=>{ //получаем дынные Buffer. Есть такой объект Buffer он хранит строки и в нём еть методы
// //можно так: 
//     // let string = Buffer.from(content).toString();// высер
//     //console.dir(content.toString());//боле менее способ
//     // console.dir(content);//проще utf-8 указать 

//     //console.dir(content);

//     console.dir(content);
//     var separator = /\r\n/g;
//     let limit = 5;//ограничене в 5 элементов в массиве
//     let rep = content.replace('/\c/','')
// console.dir(rep);
//     var newstr = content.split(separator, limit);

// //console.dir(newstr);  

// });


//console.dir(text);

//let text = fs.readFileSync('./test/text.txt', 'utf8');//поудобней 
//console.dir(text);


// for(let key in fs){
//     console.dir(fs[key]);
// }



/*
* ##########-----Слежение за изменениями файла или каталога-----########### 
*/

/*
    Вообщем fs.watch срабатывает за 1 изменение больше 1 раза. Метод официально с багом
*/
 //fs.watch('./test', (eventType, filename)=>{//следит за изменением имени файла или каталога
 //    console.dir(eventType);
 //    console.dir(filename);
 //});

/*
    [options]
    {
          persistent: true[по ум.] - процесс слежения работает пока простамтриваются файлы
          recursive: false - следует ли просматривать все подкатегирии или только текущий каталог
          encoding: 'utf8'
    }
  cdllbacl
  1. eventType или 'rename' или 'change'
  2. filename - что за файл был изменён
*/

/*
    fs.watchFile работает медленно. Официально тормозной. Рекомендуют использовать watch
*/

// fs.watchFile('./test/text.txt', (after, before) => { 
//     console.dir(after);
//     console.dir(before);
// });


/*--------Потоки------------------------ 
Что такое потоки. Это чтение и запись данных частями. Имеет ряд преимуществ с 
буферной системой. 
- Меньшее использование памяти за счет чтения содержимого по частям;
- Для объемных файлов время между запросом и ответом существенно сокращается за счет того, что данные начинают поступать по частям, а не после полной загрузки;
- Возможность перенаправить данные в другой поток с помощью метода pipe()

    Существует метод который выводит текст постепенно, а не пытаеться вывести всё и сразу,
    это делает загрузку быстрей.Так же можно куда либо записывать пошагово.
    Это используеться на сайтах выдавая пользователю информацию по кусочкам
*/
let textRead = fs.createReadStream('./test/text.txt',{encoding: 'utf8'}).on('data', (e)=>{
    fs.createWriteStream('./test/gg.txt').write(e);
})

/*
    Можно записать проще. Из-за того что зперации перемещения одного потока в другой слишком частые,
    то изобрели метод pipe который вызываеться у объекта имеющего информацию нужную нам или точней сказать,
    у потока чтения и передаёт потку записи, который принимает в качестве агумента
    и 
*/
let pi = textRead.pipe(fs.createWriteStream('./test/gg.txt'));//метод возвращает поток чтения


fs.rename('./test/new.txt', './test/old.txt',(err) => {})//переменовывает файл



