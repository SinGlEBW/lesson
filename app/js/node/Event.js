const EventEmitter = require('events');
/*
Как я понимаю можно вешать события на разные действия. 
Все объекты, генерирующие события, являются экземплярами класса EventEmitter

Создаётся сначала экземпляр события, потом обращаемся к методу on что бы событие создать. 1й пар. название, 2й пар. функция которая должна отработать
можно как сделал я.

let x = new EventEmitter().on('myEvent', function(a1){
    console.dir(a1);//ссылается на экземпляр как положено, но при стрелочной функции он теряется
});
//emit 1 - название ивента, 2 - передача аргументов в функцию моего ивента
x.emit('myEvent', {fff: 33});// вызывает это событие/ пока не совсем понятно чем отличаеться ивент от обычной функции
*/
//(function name(){console.dir(33);})()
//раз ивент класс то можно наследоваться


class A extends EventEmitter{//наследуем методы. Кстате в консоле метод on чё-то не видать
    methodCreate(nameEvent, callback){//очередной дебильный пример владилена. Обращение к методу в классе для создания эвента.
        this.on(nameEvent, callback)//его напрямую можно создать что я и сделал ниже.
    }
    methodCall(nameEvent, param){
        this.emit(nameEvent, param)
    }
}
/*
Логика такая. Прикидываем что у нас в классе есть метод отвеающий за создание пачки событий,
подготавливаем такие методы.
1й создаёт ивент, 2й вызывает и передаёт параметры
*/
/*
    Вообще класс наследует эвент, а значит и объекты наследуют.
*/
let pp = new A();
pp.on('car', (model)=>{
    console.dir(model);
});
pp.emit('car','BMW');

/*
    Есть старый способ передать эвент конструктору т.к. классов небыло
*/

let util = require('util');
function Car(model){
    this.model = model;
}
util.inherits(Car, EventEmitter);//Конструтор и ивент

let germany = new Car('BMW');
console.dir(germany);
germany.on('speed',(speed)=>{//метод once регистрирует событие только один раз.
console.dir(speed);
});

germany.emit('speed', '250 km');
germany.emit('speed', '251 km');//2й не отработает

console.dir(EventEmitter);
/*
    Событие может не отработать по каким либо причинам поэтому нужно отслеживать ошибки.
    Для этого можно истользовать класс Error
*/

germany.on('error', (err)=>{
    console.error(`Сообщение при возникшей ошибке ${err}`);
})

germany.emit('error', new Error(415));

/*
    При создании своих событий система их записывает как newListener и добавляет в 
    пул событий который просматривает Event Loop
    Некоторые методы Эвента
    addListener(имя, функция) - тотже самый метод on
    removeListener(имя, функция) - удаление
    off(имя, функция) - тот жу самый removeListener
    eventNames() - показывает все имена событий
    listeners(имя события) - накой то хрен возвращает копию события
    //События храняться в массиве очередь определяеться последовательностью
    prependListener(имя, функция) - событие будет перенесено в начало массива и вызвано раньше других 
*/


// for(let key in germany){
//     console.dir(key);
    
// }

//console.dir(germany.listeners(germany));






