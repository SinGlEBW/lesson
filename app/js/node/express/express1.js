const express = require('express');
const path = require('path');
const fs = require('fs');
const ejs = require('ejs');
ejs.delimiter = '?';

let filePath = path.join(__dirname, '../../');



let app = express();
app.set('view engine', 'ejs');//указали в объект settings какой шаблонизатор подключаем
let server = app.listen(3000);//установка сервера

let arrPages = ['lk', 'about', 'news']; 
/*
app.get('/', (req, res) => {  
    console.log(req.headers['From-Middleware']);
    res.sendFile(`${filePath}index.html`);
})
*/
/*
    "use" отрабатывает в 1ю очередь. 
    Если нам поместить метод express.static(filePath) - в который указывается корень файлов, которые возможно будут запрашиваться
    в других get запросах, то другие запросы get будут сами добавлять нужные запрашиваемые файлы к странице в get запросе

   
    Что нам это даёт. При ручном добавлении файлов к запросам, требуется отследить все запросы, после добавлять нужные файлы к каждому запросу.
    Если какой то запрос не отследить то и файл можно не загрузить или если добавить запрос к файлу, то можно не обработать загрузку файла к этому запросу,
    что приведёт к зависанию запроса в воздухе.
    
    express.static(filePath) - не работает как отдельное звено. как я думал.
    app.use((req, res, next) => { express.static(filePath); next() }) - неправильная логика выполнения. Хоть все запросы проходят через "use" это 
    не даёт правильно отработать static.


*/


app.use(express.static(filePath));


app.get('/:page', (req, res) => {
    
    console.dir(req.url);
   
    if(req.params.page == 'lk'){
        console.dir(3);
        res.render('lk', {lk: false})}

})

app.post('/lk', (req, res) => {
    console.dir(4);
    req.on('data', (chunk) => {
        
        console.dir(chunk.toString('UTF8'));
    })
    
    res.render('lk', {lk: true})
    
})

/*
app.get('/(:page)(.html)?', (req, res) => {//(.html)? тоже пападает в params 
   console.dir(req.url);
    if(arrPages.includes(path.parse(req.url).name)){
        console.dir(3);
        res.sendFile(`${filePath}${req.params.page}.html`);
    }else
    if(req.url.endsWith('ico')){
        console.dir(4);
        res.sendFile(`${filePath}/img/favicon1.ico`)
    }else{
        console.dir(6);
        res.sendFile(`${filePath}404.html`);
    }

})

*/
/*
    И так попадаем в такую ситуацию когда куча страниц и везде повторяться html код. С помощью php 
    можно было просто его разбить по подключить через require_once в JS нужно использовать для этого нужно 
    качать всякую хуйню сторонюю в виде библиотек, так называемые шаблонизаторы и пытаться это всё прикрутить.
    Скачали ejs и подключили выше, пробуем играться.
*/

/*
app.get('/news/:id', (req, res) => {
  
    if(req.params.id === 'main.js'){
        res.setHeader('Content-Type', 'text/javascript');
        res.sendFile(`${__dirname}/views/main.js`)
    }else{
        let obj = {
            arrHead: ['Страница1', 'Страница2', 'Страница3'],
            id: req.params.id
        }
        res.render('news', {obj})//безымянный объект по любому нужен
    }
    console.dir(req.headers);
   
})

*/

/*
    render достаёт страницу типа ejs и может передавать параметры
    Как я понимаю все параметры можно передавать через DOM
*/


/*  ####---ЗАМЕТКИ---####
    Практика показала что в запросах не работает полноценно регулярное выражение, а в
    частности не выходит собрать один запрос таким образом что бы проверялось
    URL группами из возможных страниц, то есть не работает логика "ИЛИ () | ()" в запросе
    Динамический объект params просто отказывается заполняться при наличии "ИЛИ" 

    Код полностью не работает т.к. сервер запущен через express а не через Node

    Все шаблонизаторы автоматически ищут файлы в папке views

    По поводу favicon. Думаю вывод что браузер в своём непредсказуемом режиме делает запрос на иконку.
    Проверку желательно оформить на наличие запроса на иконку, даже если запроса невидать.

    По поводу записи в формате строкового литерала ES6 в обратных апострофах.
    По всей видимости не важно что в console адрес ..app\\css/style.min.css наверно методы чтения 
    сами выравнивают адрес.

    Не важно какие параметры в get запросе, важно какие я разрешил и куда их перенаправил.
    Ещё важно что работать одновременно несколько запросов не могут, поэтому если в 2х и более запросах
    встречается одна и та же обработка запроса, то отрабатывать будет 1й запрос.
    Сначала отрабатывает запрос на страницу html, а потом другие запросы которые требует эта страница.
    Есть метод "use" который работает параллельно запросу.

    Когда указываем путь к файлу, происходит запрос по этому пути поэтому get может выглядеть
    с большой вложенностью если не контролировать подачу имени.
    Получается что все пути к файлам указываются в разных файлах относительно файла в котором пишем код.
    Можно в express указать корень каталога и относительно его строить пути запроса. 
    
    Иногда можно ошибочно загрузить файлы друг на друга, а потом вдуплять почему не загрузился тот или иной код,
    для этого нужно подавать файлы тогда когда они запрашиваются, и следить
    что бы логика запроса не перекрывала другой файл

    req.xhr - (bool) если запрос был отправлен Ajax
    get параметр это по факту пометки по которым мы можем собрать нужную последовательность
    ключей по которым можно найти нужную нас статью

    Метод "use" вызывается перед самим запросом get. Этот метод может делать абра-кадабру, но следующий запрос не будет отработан.
    Что бы следующий запрос мог отработать у метода "use" есть 3й параметр в callback функции
    называется next() - эта функция просто напросто вызывает следующий запрос. Поэтому он и считается промежуточным.
    Другие запросы тоже могут быть промежуточными и что бы вызвать цепочку других запросов 
    вызывается next() в запросе.
    В чём смысл если всё что мне надо я могу выполнить в самом запросе get. или же воспользоваться одним use


    метод render не обязательно принимает 1м аргументом страницу, по крайней мере 
    в док. указано что можно даже указать "<%= arr.join(',')%>" указывать код
    
    <% начало тега
    <%_ удаление всех пробелов в начале 
    <%= Выводит значение в шаблон HTML 
    <%- Выводит значение в шаблон HTML неэкранированного типа. То есть если передать html код, то нужно использовать этот тег
    <%# Тег комментария
    <%% Выводит литерал '<%'
    %> конец тега
    -%> конец неэкранированного участка 
    _%> удаление всех пробелов в конце 
    */









