const { use } = require('browser-sync');
const express = require('express');
const path = require('path');

let filePath = path.join(__dirname, '../../');
let router = express.Router();
/*----------------Бибилиотека Express--------------------------------*/

let app = express();
app.listen(3000);//Запуск сервера. Возвращает объект Server


// let app = express().listen(3000)   app.get не верно.Т.к нам изначально нужен только возвращаемый объект app
app.use(express.static(filePath));//путь до главной папки с файлами
/*
    index.html это файл главной страницы то есть '/' нам бы пришлось потратить время и описывать каждый запрос
    отдавая css, js, кучу фото. app.use(express.static(filePath)); автоматически создаёт нужные ответы и отдаёт файлы.
    ВАЖНАЯ особенность: теперь можно не пытаться ловить запросы на "/" в этом нет необходимости
    
        О запросах.
    Чтоб не сбиться с толку: Мы на сервер с главной страницы можем делать любые запросы и это не значит что нас перекинет на клиенте на
    этот адрес. Вот картинка с главной страницы обращается к серверу: http://localhost:3000/img/quality/img4.png,
    тот же css - http://localhost:3000/css/style.min.css, но мыж на главной странице. Так что если нам надо получить на главной странице что
    то по клику то можем сделать запрос http://localhost:3000/myReq/. 
*/


app.use((req,res,next)=>{next()});//отработает кучу раз
app.use(express.static(filePath));
/*
    Когда дойдёт до express.static сервер начнёт отправлять данные по одному и получиться такая картинка.
    Верхний метод отработает, static отправит файл и будет запрашивать метод use, отработает снова 1й use,
    а потом 2й и так пока все файлы не будут отправлены. Вызывается именно use Если воткнуть console.dir то 
    мы не увидим такого. Все методы use указанные ниже обращения static будут отрабатывать на любые другие запросы кроме 
    "/"  Так что выше static ни чего можно не ставить
*/








/*
    Middleware - промежуточные функции. На сервере методы use, get, post, delete, put, route и т.д. 
   
    это события, тот же addEventListener по сути, но реагирует на поступление запросов к серверу.
    Эти методы могут выполнять не 1 функцию, а много, они и считаются промежуточными или Middleware
        метод use кстате отрабатывает при любом запросе к серверу.
   get('/',(req, res, next)=>{ ...; next()}, (req, res, next)=>{}, .... ). Можно прям массив имен наших функций передать.

    Вместо объекта event тут 3 параметра. Объект запроса на сервер, объект с методами ответа с сервера и чтоб перейти к следующей функции 
    при успехе вызываем next().
    
    
    В запросе можно устанавливать регулярные выражения, таким образом отсекаю возможный ввод
    суффикса
*/
//получение смешанных запросов
app.route('/page')
    .get((req, res) => {
        res.writeHead(200);
        res.sendFile(`${filePath}index.html`); //инструмент библиотеки удобней добавлять файлы
    })
    .post((req,res) => {
        console.dir('Отправлен POST');
        res.sendFile(`${filePath}index.html`);
    });

    
/*
   Частые методы объекта response
    .send() - отправлять можно {},[], Buffer.from("Hello Express"), даже строку в которой можно указать html но это не круто
    .sendFile() -Указывается полный путь html файла для его отправки. 
    .sendStatus(200) - код статуса
    .status(200).send() - связка



  Объект запроса
    .app - содержит ссылку на объект приложения Express
    .baseUrl - базовый путь, по которому приложение отвечает
    .body - содержит данные, представленные в теле запроса (Что это работало надо предварительно ставить use(express.json()) или пакет body-parser)
    .cookies - содержит данные cookie, отправленные по запросу (требуется промежуточная программная обработка cookie-parser)
    .hostname - название сервера
    .ip - IP сервера
    .method - используемый HTTP метод
    .params - параметры запроса в роуте
    .path - URL путь
    .protocol - протокол запроса
    .query - объект, содержащий все параметры запроса
    .secure - true если запрос безопасен (использует HTTPS)
    .signedCookies - содержит данные cookie, отправленные запросом (требуется промежуточная программная обработка cookie-parser)
    .xhr - true если запрос отправлен с помощью XMLHttpRequest

*/


// через регулярные можно реагировать на запросы к серверу URL и регулярный подход нужно отделять группами иначе не сработает

let arrPage = ['about', 'news', 'lk', 'status'];//массив возможных страниц
app.get('/(:page)(.html)?', (req, res) => {
    console.dir(req.headers);
    if(arrPage.includes(req.params.page))
       fs.createReadStream(`${filePath}${req.params.page}.html`).pipe(res)
    else
        fs.createReadStream(`${filePath}404.html`).pipe(res)
    
})



app.get('*', (req, res) => {// * - любые другие get запросы,
    console.dir(3);
    fs.createReadStream(`${filePath}404.html`).pipe(res)
})


/* Альтернативный вариант
let router = express.Router();//т.к объект роутер модульный, без use работать не будет
app.use('/', router);//1й пар. маршрут, 2 callback. 1й парам может и не передаваться

router.get('*', (req, res) => {
    console.dir(3);
    fs.createReadStream(`${filePath}404.html`).pipe(res)
})

*/

/*
    Немного о шаблонизаторе. Нужно это для того чтобы по 100 раз не вводить одно и тоже в html
    Шаблонизаторами можно работать в html как это делает php код
    handlebars - один из шаблонизаторов

    Запросы можно посылать так же через объект router присвоив изначально его переменной получи из объекта 
    express. let router = express.Router(). Разница между app.get и router.get заключается в том что router.get 
    используется в коде когда идёт разбивка кода на модули, при этом нужно привязать router к папке с которой он должен рабоать
    use('/', router) 

    Про Get запросы. 
    в URL ссылке присутствует знак ? после которого обычно задаются get параметры
    Пример Запроса: /api/books?page=3&limit=15
    в объекте request есть объект который принимает данные параметры называется 

    query {
        page: 3,
        limit: 15
    }
    Про динамическое изменение страниц и объект params уже разобрался
    Пример Запроса: /api/какая-то страница
        Настроенный мой маршрут /api/:page
    params {
        page: введённое значение
    }


    Небольшое описание
    app.all(путь, callback) - выполнит если будет любой запрос, даже те которыми я не знаю
    кстате говоря app.all больше схож с app.use т.к. они в принципе реагируют на любой запрос.
    Если мы знаем точно какой хотим получать запрос то лучше использовать его,
    что бы не писать лишний код на дополнительную проверку GET это или POST
    возвращать next() чтоб запрос не застрял.
    
    app['m-search'](путь, callback)  - доп запросы express'a указываются как массив
    app.route()

    Middleware это функции которые вызываются в методе use()
    - методы get(), post() и т. д., также являются функциями промежуточной обработки, 
    которые не передают вызов дальше.
Запросы.
    Связь клиента с сервером осуществляется через запросы и ответы от сервера.
    Что бы совершать запросы на сервере требуется установить библиотеку запросов.
    Запутано и сломало мне мозг, но работает это примерно так: Я как бы имитировал отправку запроса
    проходил 3 метра, брал данные Ajax'ом и отправлял запросы куда требовалось, далее
    получал его и выводил в html. 
    Здесь же немного иначе и не совсем понятно. 
    1е)В Ajax запросе мне всё же нужно было указать адрес, а тут NodeJS 
        слушает страницу и при её изменениях может реагировать.
    2е)Мне приходиться посылать запрос на сервер потом с сервера

    Вообщем если требуется посылать запросы на сторону то можно через Ajax или через сервер
    - можно самому посылать запросы к стороннему API если установить npm install request --save

*/



