/*Promise Принимает функцию (Функция исполнитель) которая отрабатывает при определении объекта. Эту функция принимает 2 параметра. Параметры это callback функции.
В Promise может отработать одна функция, та которая встречается 1й.
а уж какая функция должна отработать 1й и какие задачи будет выполнять эта функция будет зависить от программиста.
Обычно 1 параметр вызывают под положительный результат, а 2й под отрицательный. Если заглянуть в Promis, 
то 1й аргумент будет иметь статус "resolve", 2й "reject", без вызова функций статус "pending".
Нужно создавать условие какая функция должна отработать. После того как создали условие по которому та или иная функция вызоветься, нужно передать прототип этим callback'ам.
then отвечает за передачу прототипов. Можно передавать через запятую и для 2го параметра который отвечает за статус reject.
Метод catch создан для передачи calback 2му аргументу, вообщем отвечает только за статус reject и ни как не связан с resolve.

    А что если мы ходим сделать несколько действий с положительным результатом?Хотим чтоб этот результать побывал не в одной функции передаваемой в then, а в нескольких?
    В Promise вызовается callback функци одна и мы по можем привязывать новые прототипы, через then.*/
/*resolve и reject встроены в js. Это сразу не заметно, но если попробовать вызвать callback в любой функции то она потребует от нас получить прототип 
  как только запустим функцию. Промис же не спрашивает. Это как заглушка. Мы передаём свой прототип, я так понимаю. */
/*Важно понимать: resolve и reject это всё условности. Смысл заключаеться в том, чтобы выполнять какие, то действия при отработке одно функции,
и другие действия при отработке другой функции И все обращения к Promis будут выполняться последовательно(тоесть асинхронно).
Но что бы эта асинхронность была, то запросы нужно строить с однем обращением к объекту и передавать новый запрос из предыдущего then новому then.
Вот только передавать нужно Promis а не значение */
/*
var prom = new Promise(
    (f1, f2) => {
        var Random = Number((Math.random() * 100).toFixed(0));
        if (Random > 50) {
            f1(Random);
        } else {
            f2(Random);
        }

    });
    */
/*И так как мы уже знаем что reject и resolve это условности и по факту отрабатывает одна из функций, то мы можем
  иметь такую цель: На каждом запросе у нас есть по 2 ответа, выбран должен только один ответ */


// prom.then((int)=>{console.log(int + i1); return prom},
//           (int)=>{console.log(int + i2); return prom})
//     .then((int)=>{console.log(int + i3);},
//           (int)=>{console.log(int + i4);})

/*
prom.then((int) => {
        console.log(int);
        console.dir(prom);
        return prom
    })
    .then((int) => {
        console.log(int);
        return prom
    })
    .then((int) => {
        console.log(int);
        return prom
    })
    .catch((int) => {
        console.log('Ошибка');
    })
*/
/*В чём де смысл catch. Так как сосояние Reject всё же подразумевает обработку ошибок, но мы использовали обработку ошибок просто для вывода числа.
  Что происходило с числами. Если ворачивался статус recolve, то все then выполнялись с этим статусом друг за другом, если reject то происходило тоже самое.  
  Тоесть статус определяеться единожы для всех обращений через then. 
  Я так понимаю что статус может менять от каждого запроса. Указание каждому запросу своего обработчика ошибок не выводит из под контроля все запросы.
  Если их будет куча и где то в середине будет запрос с ошибкой, то в случает с обработкой на каждом этаке код продолжит работать, а в случае с catch
  код начнёт передвигаться по коду и будет искать обработку ошибок до самого конца.
  Указание каждому запросу своего обработчика даёт возможность обработать 
  Если всё же использовать reject как оповещение об ошибке, то можно указать единожды */



/*Чем отличается then от catch если для resolve и reject прототипы функций можно предать через then*/


/*
    Чем отличаеться синхроный код от асинхронного. 
    Во 1х это путает людей т.к. понятие в жизни Синхроность это одновременно, а асинхронно последовательно как минимум.
    Это очередной раз кто-то объебался с названием ну да ладно.
    Синхроный код означает типо выполнение кода последовательно, функции так же могут возвращают какое-то значение и 
    им можно пользоваться за пределами функций. Выполнение дальше не продолжиться пока не будет выполнен предыдущий код скажем так. 

    Но в js код не ждёт никого поэтому выполняеться может одновременно несколько функций в общей сложности  
    Асинхроный используется в callback функциях.
*/


function myFunc(){
    return Promise.resolve({name: 'Вася'});
}


let result = myFunc().then(function (data){ console.dir(data) } );
//или
async function res (){
    let re = await myFunc()//await работает только в функции async и может работать с другими объектами промис
    console.dir(re);
}

res()